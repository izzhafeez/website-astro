{
  "CFG1002": {
    "title": "Career Catalyst",
    "semester": "AY22/23 S2",
    "grade": "CS",
    "review": "CFG1002 is a 2MC course which can be completed in one afternoon. If you need feedback points for CourseReg, CFG1002 is a good way to get them. There's also some lecture you have to attend nearing the middle of the course, but otherwise, there's basically no workload. If you're planning on taking it for the content, here's the breakdown:\n1. Resumes and Cover Letters.\n2. Personal Branding.\n3. Interviews.\n4. Networking.\nThe content itself may seem quite simple, but it actually builds certain intuitions that are hard to develop otherwise. Don't assume you know everything about it, because there are quite a number of small details that can make a big difference. Here's the breakdown of the completion requirements:\n1. Passing grade on Canvas Quizzes.\n2. Set up accounts on ConnectUS and IAAS.\n3. Elevator Pitch on VMock.\n4. Resume submissions on VMock (you have to get a passing score).\nOverall I think it's a good course to take and finish during the first week of school. They give you everything at one shot, so why not finish this while the workload for your other courses is still low?"
  },
  "CFG3001": {
    "title": "Career Advancement",
    "semester": "AY23/24 S1",
    "grade": "CS",
    "review": "CFG3001 is a 2MC course which can be completed in a week. This is a good source of feedback points if you need them for CourseReg. It is pretty similar to CFG1002, but it focusses on different things. In particular, it emphasises the need for a personal brand, and discusses more advanced tips on how to network properly. Concepts like VIPS will be thrown around often, as a sort of framework for self-analysis. That said, the workload may be a little higher than CFG2001:\n1. Canvas Quizzes.\n2. conNectUS Profile setup, and you have to do a forum response.\n3. Set up an informational interview with someone in the industry (you need to show proof that you did it).\n4. Jot down what you learnt from the informational interview in a reflection journal.\n5. Use the VIPS framework to analyse your own skills.\n6. VMock interview practice.\nMost of them were fine, but the one that sizzles my spring onions is the VMock interview. It requires you to turn on your camera, then VMock will analyse your facial features (whether you're smiling, looking away, body language etc). But the thing is, my face is dark, so VMock was having a very hard time detecting my face. It took me a few tries to even get it to start the interview. Turning up the light, moving closer, changing angles, until I got the right combination of all. Goes to show how biased the facial recognition is. But I digress. Overall, I think it's a good course to take, especially if you're planning to go for internships or jobs soon. It's a good way to get your feet wet in the industry."
  },
  "CP2106": {
    "title": "Orbital (Independent Software Development Project)",
    "semester": "AY22/23 S1",
    "grade": "Artemis",
    "review": "Orbital is something that many year ones will take during their summer break. For those of us who didn't manage to get an internship during our first year, this Orbital programme is a good second alternative.\nIt's pretty much a pair-work course, as you and your partner will have to create one sophisticated project from start to finish. If you're struggling to find a partner, Reddit is always a good option. That's how I found mine.\nNext, let me explain the different levels of Orbital. Before the development period commences, teams can decide to go for different achievement levels. They are a good gauge of how complex you want your project to be, indicative of the amount of effort you want to put in, and decides what requirements you will have to meet to pass the course. I took the Artemis level, the highest level you can achieve in this course. While there are some fixed requirements such as code reviews, testing and promotional videos, the rest of the requirements are more... subjective. In other words, your TA has the ultimate say whether you belong in that achievement level. Which means that if you get a sadistic TA, you will have to work extra hard to maintain your achievement level. Luckily, I managed to get a pretty chill TA who found our application suitable enough for Artemis level. From there, the requirements become more relaxed, as we move from Artemis, to Apollo, to Gemini, and finally to Vostok. The bulk of the teams opt for Gemini, as there is not much difference from a Vostok level.\nIt's hard to gauge how much effort to really put into the different grading requirements. I think I may have gone a bit overboard with the software engineering practices. I did WAY too much testing, including unit tests, integration tests, system tests, performance tests and more. I also did WAY too much documentation, including my 81-page final Orbital report. Surprisingly, it didn't take too long, but still, 81-page is no joke. Don't really have a benchmark on how much you should do, but just know that you have to convince your TA that you're doing enough.\nThe rest is up to you. Build anything you want, as long as it's related to software. Can be a robotics project, can be a game, can be a web application. From seeing past submissions, the best project award always goes to some game, because it is immediately obvious how much effort was put into it. By adding more game mechanics, you can easily make your game more complex and sophisticated, earning more points on that aspect. But if you want to make it easier for people to test your project, please make it a web application and deploy it on some site like Netlify. Don't make it a mobile application and expect people to use it on Expo Go. The next time I have to open up Expo Go, I'm gonna give that a bad review.\nOverall, I think if you can find an internship in your first year, then you should do that instead. But if can't, then this project is a good first step.",
    "fairness": 4,
    "retention": 4,
    "grindable": 5,
    "usefulness": 4
  },
  "CP3200": {
    "title": "Student Internship Programme I",
    "semester": "AY23/24 S1",
    "grade": "CS",
    "review": "SIP I is usually taken in your Y2 summer break, based on the MC requirements set by SoC. It's a 12-week internship, and you have to work full-time. Besides the internship workload, however, there isn't that much that you need to do.\nFirstly, if the internship was not found using NUS TalentConnect, you have to instruct the company to post a listing on the platform. After a few email exchanges back and forth, you should be able to apply for that role under SIP I. If not, then please inform the necessary people that you are unable to do it. Don't leave it to the last minute.\nBut it's pretty much straightforward from there. At the start, you write down your initial objectives, which basically states what you plan to learn and accomplish during your internship. Afterwards, you have to submit monthly reports to monitor your progress through the internship. The big thing you have to worry about comes at the end, where you have to submit a Final Report, which is about 2000 words long. If you've been doing your internship properly, then this report shouldn't take too long to write. There is also an internship presentation with your SIP TA. Nearing the end of your internship, just book a 15-minute slot with your TA in the evening and just present. Don't be stressed about this, as it's quite an easy presentation if you've actually been doing work in your internship."
  },
  "CS1101S": {
    "title": "Programming Methodology I",
    "semester": "AY21/22 S1",
    "grade": "A",
    "review": "Please don't take the exemption from this course. It is absolutely necessary. CS1101S is the first computing course you will take as a CS student. If you're not in SoC, you would be taking some variant on CS1010 instead. The difference here is that CS1101S is taught in a JavaScript-like language, while CS1010 is mainly taught in more traditional languages like Python and C.\nThis course is one of the biggest time sinks in your first semester. The workload is notoriously heavy, thanks to the gamified platform that the course administrators have kindly prepared for us. Source Academy. It keeps track of all our course-related materials, and uses XP to determine how many marks we get for that component. Basically everything gives XP. Tutorial participation, homework, quizzes, and many more optional content. Don't worry, you won't need to score full marks to clear this component. As long as you maintain a decent XP score for each compulsory assignment, then you should be able to clear this component quite easily. Most people do, anyway.\nBesides the practical exams, the midterms and finals heavily test you on data structures like lists, pairs and streams. But the one that drains my rice is the Environment Model, which is basically tracking how many function calls are made in a program. There's a lot of arbitrary definitions in place, with not a lot of room to practice. Build the intuition by looking at many examples. I learn best when I have lots of positive or negative feedback for my answers, which was pretty hard to get here. So I reworded many of the definitions to language that I can understand.",
    "fairness": 3,
    "retention": 2,
    "grindable": 2,
    "usefulness": 3
  },
  "CS1231S": {
    "title": "Discrete Structures",
    "semester": "AY21/22 S1",
    "grade": "A+",
    "review": "This course is the first introduction to rigorous math. The main focus is on proving techniques, and the different types of proofs that you can use to prove a statement. If you don't come from a math-intensive background, this course may be the bane of your existence. Some people find this course fun and interesting, and some people will curse and swear at this even up till graduation.\nThe course starts rather simply, teaching the basics of logic and logical inferences. Then we slowly build up our intuition on sets, relations, functions, trees and graphs. But the truly painful part of the course comes after the recess week. Cardinality. Cardinality basically deals with the size of sets. Given set A and its relationship with set B, what can we say about the size of set B? Based on the question design, this can get very confusing very easily. As such, one good tip is to see how many marks the question gives you. If it's high, then you're likely expected to give a full proof for it. If it's relatively low, then the answer is likely much more straightforward than you're thinking. This narrows down your options quite a bit, so don't overlook it.\nOverall, nailing down the fundamentals of proving is extremely important, as you'll be needing it later down the road when taking CS2040S and CS3230. And of course, if you're taking any math mods, then this is basic knowledge. No way around it.",
    "fairness": 4,
    "retention": 4,
    "grindable": 3,
    "usefulness": 3
  },
  "CS2030S": {
    "title": "Programming Methodology II",
    "semester": "AY21/22 S2",
    "grade": "A+",
    "review": "Ah welcome to the world of Java. This course teaches the two programming paradigms: Object-Oriented and Functional. We start off the first 2 weeks learning about types and declarations. The next 4 weeks sees OOP concepts like inheritance, polymorphism, and encapsulation. Out of the earlier concepts, the stack and heap model really tears my tofu like paper. It basically represents where different things are stored in memory. Your variables, your functions, all captured in stack frames or dumped on the heap. Drawing the arrows to connect the different components was absolute pain, and I got 1/8 for that question in the Midterms. With no feedback loop to practice, this was expected. My midterms were in the bottom 25 percentile.\nObviously the second half of the semester was where I did my best. Functional Programming, and the beauty of Monads. What is a monad? Well, a monad is a monoid in the category of endofunctors, which states a few basic rules that it needs to follow. With those basic guarantees, we can compose different functions together to achieve the result we want. Pretty abstract, but also where I excel at.\nIn terms of workload, I'd say CS2030S has a much higher workload than CS2040S. The weekly labs are done on SoC servers, which means you need to be comfortable with working in the Vim code editing software. Using the mouse is not recommended in Vim, and you need to learn basic navigation skills like how to quit Vim. The lab content was fine. You have to implement some functionality in Java, like Optional or Try types. Basically what you've learnt in the lectures, but in a more practical setting. Boring as heck, but still manageable. You will have all these test cases that determine your score for the lab. The thing is, you are not given all the test cases, only the public ones. This means that you have to make sure you cover all edge cases so that you can pass all the private test cases as well. Furthermore, you need to use the concepts that they taught ie there is an intended way to do it, and you are marked based on your compliance to that way. This is essential for nailing the Practical Exam, which I got full marks for.",
    "fairness": 4,
    "retention": 3,
    "grindable": 4,
    "usefulness": 4
  },
  "CS2040S": {
    "title": "Data Structures and Algorithms",
    "semester": "AY21/22 S2",
    "grade": "A",
    "review": "Probably the most important course for technical interviews. This is a crash course on all things algorithms. The course starts off with the basics of complexity analysis, then moves on to sorting algorithms, searching algorithms, tree algorithms and finally graph algorithms.\nBe prepared to spend a lot of time on the sorting algorithms, as there are like 6 of them. You have to know what each of them does, what are their invariants, and what conditions are best for them. Put these all in your cheatsheet and you should be fine.\nFor complexity analysis, you are mainly dealing with loops and recursions, so take note of how many loops there are, and how many times the loops run. A rule of thumb would be:\n1. If you're in a loop and the variables are incrementing by a fixed amount, then think linear O(n).\n2. If you're in a loop and the variables are changing by multiplication or division, then thing O(logn).\n3. If you're using recursion and calling f(n-1) twice, then think exponential O(e^n).\n4. If you're using recursion and calling f(n-1) once, then think linear O(n).\n5. If you're using recursion and calling f(n/2) a fixed number of times, then think logarithmic O(logn).\nTree algorithms are very error-prone, as there are so many different edge cases you need to worry about. The AVL tree, for example, is a self-balancing tree, which means that when things are added or deleted, the tree needs to be able to rearrange itself to not let any side be too long. Remembering and coming up with the edge cases is not a easy task.\nLastly, for the graph algorithms, the star of the show is the Dijkstra algorithm. It's the most famous out of them, but with a little tricky implementation. It's a valuable algorithm to learn and master.\nAs for workload, we use the Coursemology platform, which gives score based on the amount of XP you earn from homework and tutorial participation. Again, you don't need to worry so much about getting full XP for everything, as most people get it anyway. Homework is usually solving some algorithmic problem, and you use the different data structures and algorithms you're learnt to solve them. They're all in Java, so it is typically recommended to take this course alongside CS2030S. I usually finish the problem sets within 2 hours of the release, so it's not too bad. I'm usually one of the first ones to submit their work, which means I usually get my XP very early on, easily putting me near the top of the leaderboard week after week.\nThe midterms and finals are pretty manageable, as they test you on your problem solving skills. Be prepared to write lots of pseudocode and draw lots of diagrams. Don't waste time writing curly braces or writing type declarations, as these all will slow you down. Instead, just focus on writing the core structure of the algorithm IN PENCIL, and if you have time after completing the questions, then you can go back and fill in the details. What they are testing you on are your concepts, and NOT your knowledge of Java syntax. So don't worry too much about that.",
    "fairness": 4,
    "retention": 4,
    "grindable": 5,
    "usefulness": 5
  },
  "CS2100": {
    "title": "Computer Organisation",
    "semester": "AY22/23 S1",
    "grade": "A-",
    "review": "The course has a very unique progression. It starts off in C programming, teaching fundamentals like addresses and memory management. Then, we drill down to the bare bones of logic and electrical components. So from C, we go down to assembly language (human-readable instructions for the machine), then to machine code (1s and 0s), and finally to logic components. From there, we slowly build up our circuit components, achieving more complex functionality like Adders and Multiplexers. Just know that you'll be dealing with a lot of logic diagrams to figure out how to design your circuit. This was the fun part. Circuit design.\nBut the last 3 weeks really colanders my rice. Process Scheduling is about calculating how long a sequence of instructions will take to execute. It's not a simple task, as each instruction is composed of many stages, which are handled in different parts of the machine. The execution of these stages can be done concurrently, which leads to awfully long and convoluted calculations. Memory management, on the other hand, was a little more manageable, but was still very pain. It's about how the computer caches data, and how it can be optimised to reduce the time taken to access data. Lots of calculation to see how much time is saved, and how much of the cache is actually used.\nExpect exam questions to have a lot of arbitrary calculations. That is, calculations that you have NO WAY of knowing whether you are right. The worst kind of questions for me. No intuition involved, just following instructions. You are the computer. Be the computer.\nThat said, the workload isn't very high, just a bunch of low-effort labs that can be done in 5 minutes. It's just a mountain of content you need to get through.",
    "fairness": 2,
    "retention": 2,
    "grindable": 2,
    "usefulness": 2
  },
  "CS2101": {
    "title": "Effective Communication for Computing Professionals",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "This module is a good starter pack for soft skills. Though it may seem as fluff for most people, I think it's not. We computing students don't really have any soft skills, especially as compared to other majors like Business. We don't have that high of a tutorial participation weightage, and lectures don't have any participation marks. Which makes this course one of only two computing mods that actually teaches soft skills. This course is twinned with CS2103T, which means that your team for CS2101 and CS2103T will be the same. Make sure you get good and reliable teammates, as you'll be stuck with them for 8MCs worth of courses.\nContent-wise, I actually find the topics and discussions quite helpful. It heavily encourages us to speak up more during lessons, as tutorial participation is quite high. We are encouraged to share our answers with the class very often.\nAs for workload, it's a little on the heavier side, as we have 2x2h tutorial slots every week, which makes it a little difficult to plan your schedule around. But other than that, it's quite a low-effort course. Your grade is heavily influenced by how much your tutor favors you, so be sure to be memorable in class and participate a lot. As for specifics, you will have two presentations (one on a career-related topic, and one about your CS2103T project), the User Guide from your CS2103T project, and two reflections. That's pretty much it. With reliable teammates, it's quite manageable.",
    "fairness": 2,
    "retention": 1,
    "grindable": 2,
    "usefulness": 3
  },
  "CS2102": {
    "title": "Database Systems",
    "semester": "AY22/23 S1",
    "grade": "A",
    "review": "This module is not all about SQL. Maybe just the first half is. The first half teaches about SQL queries and schema, and the difficulty ramps up with each lecture, so be sure to not skip any of the fundamentals. It starts off with simple select statements, but you'll eventually add more and more syntax like WHERE, JOIN, GROUP BY, HAVING, and more complicated ones like CTE, subqueries, recursion and functions. These later ones are the mind-blowing ones, as they are not what you'd typically associate with SQL. But they are still somewhat useful to know. Just make sure your earlier topics are solid, as most places would likely need that level of SQL understanding.\nThe second half is about designing your database. Each database needs to store many different fields. This chapter is about how you group these fields into different tables to ensure certain guarantees. These is all under normalisation, which is formalised using algebraic notation, quite simple to understand actually.\nAs for the workload, it's quite low honestly. You work in groups of 4 to create an ER Model (which is basically a diagram of your database), then you have to create a database with SQL functions. The second assignment was significantly more difficult, because it is quite hard to debug SQL code without a mock database. But other than that, there is one tutorial presentation you have to do and nothing much else.\nThe midterms was a little tricky, as you have to write working SQL code to perform certain queries. That in and of itself isn't too hard, but the time crunch definitely makes it feel like an actual PE. The finals was a little more standard, as it was more about your theory concepts, and how you apply normalisation rules to design your database.",
    "fairness": 3,
    "retention": 3,
    "grindable": 4,
    "usefulness": 4
  },
  "CS2103T": {
    "title": "Software Engineering",
    "semester": "AY22/23 S2",
    "grade": "A+",
    "review": "This module teaches proper software engineering techniques and processes. The primary language is in Java, but you'll also learn Git for version control and Markdown for documentation.\nLots of diagrams like sequence, class, object and activity diagrams. These help to explain how your code works to someone new to the codebase. Lots of notation and conventions you have to follow and memorise. You will always see these types of questions in the finals. All the small details, all the minor nuances in the notation that you have to pick up and determine whether they are right.\nLots of Git theory was taught as well, how to branch, how to pull request, how to merge conflict, how to do CI/CD, how to use the Issue Tracker. All very basic skills that all of us need to know in the industry.\nAll this leads to the projects. There are two main projects that you'll be doing during the semester.\nThe first is the Individual Project (IP), which tasks to make a to-do list with specific functionality. The requirements are given to you week-after-week, and your progress is tracked through GitHub and shown on a leaderboard. The objective of this IP is to get you familiarised with Java and the Git workflow, which is helpful as we don't want people messing up the Team Project (TP).\nThe TP is where you'll spend a good 7 weeks on. You are given the code for an Address Book written in Java, and you're supposed to revamp it to add more functionality. Add more features, beautify the application. Those kinds of things. The requirements are quite open-ended, so you can do whatever you want. Just make sure that you sufficiently test your code, as it is very important for the Practical Exam (PE).\nBasically, in the PE, you will have to test the code of other teams, and find bugs in their code. The more bugs you find, the higher the score you'll get. At the same, if the code that your team wrote has many bugs, then you'll lose the points. So, don't develop a massive codebase that you can't fully test.\nBut then again, this goes in conflict with CS2101, which requires you to 'sell' your product to the class. So, you have to balance between making your product look good, and making sure it works well. It's a tough balance, but it's a good experience to have.\nOverall, I think this module is a good introduction to software engineering. A good baseline for the number of lines of code to contribute is 2k, leading to a 10k line codebase for the group. These figures are tracked on the dashboard, so you can easily see what others are up to. In the end, I contributed over 18k lines of code, so I was quite happy with my performance.",
    "fairness": 2,
    "retention": 2,
    "grindable": 3,
    "usefulness": 5
  },
  "CS2106": {
    "title": "Introduction to Operating Systems",
    "semester": "AY23/24 S1",
    "grade": "A-",
    "review": "Wah this one pain. This course is all about the OS. How it manages its CPU, memory, and processes. The first part is all about how the OS schedules tasks on the CPU. Then we learn how the OS manages different threads to run concurrently. Those parts are relatively okay, just need to know the relevant C code.\nAfter that though... hais... We have lots of memory issues. Different processes need to communicate with each other, which means they either use shared memory or have to rely on message passing. Basically, either they share a mailbox, or have a mailman transfer mail between the two mailboxes. The mailman is of course the OS. We need to implement this in the labs, using pipes in C, which allows processes to talk to each other.\nBut wait, there's more. By enabling concurrency, we introduce a lot of new problems. This is synchronisation, something we need to do to ensure that the correctness of the program is maintained. In C, we are taught to do this using semaphores, which are basically locks that you can put on a resource. If you have the lock, then you can access the resource. If not, then you have to wait. This is a very tricky concept, as you have to ensure that you don't deadlock.\nIn terms of workload, I'd actually say that it's not very high. There are just 4 labs. Sure, they may take a while to grasp, but once you understand the requirements, the implementation itself isn't that hard. Probably took me 4 hours per lab to complete. Not that bad.\nBut I think I died in the exams. It's again my worst exam format, testing minute details and small nuances. The calculation questions aren't too good either, as getting one number off will get you no marks. My concepts aren't great either, as I didn't really understand the material too well. As such, I think I got a little lucky with the grade, as I was expecting a B or B+.",
    "fairness": 3,
    "retention": 2,
    "grindable": 2,
    "usefulness": 4
  },
  "CS2108": {
    "title": "Introduction to Media Computing",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "The course is all about signal processing and how to compress data. This is pretty important in the real world, as we need to be able to send data over the internet quickly and efficiently. The first part is all about the Fourier Transform, which basically converts signal data from the spatial/time domain into the frequency domain. Lots of math, but the prof emphasises that you mainly need to understand the concept and no need to prove or be able to derive the math. The course teaches us that high frequency components are relatively hard to detect, so even if we remove them from our signal, we can't really tell the difference. This makes a huge difference in image processing, as our eyes can't really detect pixel-to-pixel differences, but we are able to tell when a large portion of the image is distorted or warped.\nThis is the basis for the JPEG compression algorithm, which takes out most of these high frequency components and compresses the image. I'd say that is the biggest part of the course.\nOf course, there are many more smaller compression algorithms, like the LZW, Run Length Encoding and the famous Huffman Coding, which all have their strengths and weaknesses. These are algorithms that you have to know by heart, as cheatsheets are not allowed in this course. These algorithms are the ones that you can and have to do manually. You are the computer. Be the computer.\nIn terms of workload, it's quite low. You are basically implementing certain algorithms using MATLAB. Around 6 MATLAB worksheets in total, to accomplish tasks like convolution and fourier transforms. MATLAB is also one of the most unintuitive languages to learn. They start their index at 1, and use round brackets for indexing. Very weird, and you'll never get used to it.",
    "fairness": 3,
    "retention": 3,
    "grindable": 2,
    "usefulness": 2
  },
  "CS2109S": {
    "title": "Introduction to Machine Learning and Artificial Intelligence",
    "semester": "AY22/23 S2",
    "grade": "A+",
    "review": "The course is all about classical concepts in both AI and ML. In AI, the focus is about problem formulation. How we analyse a given problem and how we come up with conditions that the solution has to meet. This led to the A* algorithm, which improves upon the Dijkstra Algorithm but now we know where we want to go. We can use this knowledge to narrow down our search, leading to much faster discovery of the optimal solution. The second half of the course is all about ML, which means lots and lots of math. We stared at a lot of partial differentiation, and gradient descent formulas. Some past students complained that this course had too much math, while some of them complained that there was too little math. I think in the end, the course struck a good balance between the two extremes. Sure, the ML concepts were hard, but hey, they weren't tested as there were no finals anyway.\nAs for workload, it's all in Python, so if you're quite comfortable with Python and its associated libraries like Numpy, you should be fine. It's quite similar to CS2040S, where you have to implement algorithms and submit them on Coursemology for XP. The second half is where you'll be exposed to PyTorch, which is a machine learning library that is quite popular in the industry. You'll start off implementing things like gradient descent, and eventually you'll come round to actually building models and pipelines, using datasets to train them. All this culminates in the final practical exam, which is a 2-day Kaggle-like competition where we all have to build models based on a dataset given to us, then they would run on their servers and scores will be given based on the accuracy of the model. I did decently well for this competition, hence leading to my A+.",
    "fairness": 4,
    "retention": 2,
    "grindable": 3,
    "usefulness": 4
  },
  "CS3211": {
    "title": "Parallel and Concurrent Programming",
    "semester": "AY23/24 S2",
    "grade": "B+",
    "review": "I thought I would survive this course, but nope B+. It is a pretty tough courses teaching concurrency paradigms in three languages, being C++, Go and Rust. 6 weeks are dedicated to learning concurrency in C++, which can be done in multiple ways. The straightforward way is to use locks, which restricts access to certain resources. The more advanced way is to use atomic variables and functions. These are variables and functions that can be accessed by multiple threads at the same time, without any locks. This is a very powerful concept, but also very error-prone. You have to be very careful with how you use these atomic functions, as they can lead to very hard-to-debug errors. This topic is often merged with Memory Order, which determines how the CPU reorganises instructions to optimise the code. In a very strict mode, the CPU is not allowed to do much reshuffling of machine instructions, leading to a very predictable, yet sequential execution. The more relaxed we go, the more we allow the CPU to reshuffle its instructions, which can lead to faster execution. Of course, with reshuffling, it's your duty as the programmer to ensure that the code remains correct. This means certain key relations between variables must be maintained, using the Memory Order concept to help us reason with this behaviour.\nMoving on to Go, we mainly use channels to communicate between different Goroutines (aka your different tasks). Channels allow you to pass any kind of data between two tasks. You can send over numbers, strings, structs and even other channels. Very versatile and allows for a more modular approach to concurrency. The thing you need to worry about during implementation is how to close all of the Goroutines. Who is going to coordinate everything?\nLastly, we have Rust, and the main concept here is asynchronous programming. This feels like a pipeline, where data is passed from one task to another, and each task needs to fully complete using await before it is passed to the next one.\nDon't understand my explanations? It's okay. I don't understand them either. The course is full of high IQ people, I can't compete with them. I'm just a lowly CS student. But I think I did okay for the course, all things considered. I think I just did consistently average for the three assignments as well as the finals, leading to the expected B+.\nBy the way, the assignments were really tough. One for C++, one for Go and one for Rust. All extremely hard to debug, and hard to understand. Easily spent 4 times the time on this than I ever did with CS2030S or CS2040S.",
    "fairness": 5,
    "retention": 3,
    "grindable": 2,
    "usefulness": 4
  },
  "CS3216": {
    "title": "Software Product Engineering for Digital Markets",
    "semester": "AY23/24 S1",
    "grade": "B",
    "review": "This course is not your typical CS course. Instead of teaching CS, this course teaches the product development process. The prof doesn't teach much, but instead invites external speakers every week to share more about their industry. The first few were about UX Design and how to gather user pain points and requirements. Some lessons were about idea-generation and how to transform bad ideas into good ones (basically the mindset behind idea-generation). There was also a lesson on understanding team-dynamics, where we had an exercise to understand each other's strengths and weaknesses, workflow and behaviours. There were also quite a few startup-related lessons, including how to raise money, and how to scale up the business.\nAssignment 1 required us to produce a working prototype of our solution to a problem. It can be any problem, as long as we are able to conduct the necessary research and interviews to validate our solution. This involes the entire design iteration process, starting with identifying pain points, target audience, conducting interviews, conducting user testing and usability testing. So much user testing.\nAssignment 2 was about researching a real-world Generative AI product and present it to the class. We were tested on how well we could 'sell' the product, as well as how in-depth our evaluation of the product was. Don't be overly supportive of the product, and be sure to give the negatives as well.\nAssignment 3 was abou creating an application surrounding a certain Generative AI model. It can be anything, but the main feature has to be Gen AI. My team did ChitChatChampion, which is an online ice-breaker platform powered by GPT. This was the only assignment I was confident in.\nNote that for the first three assignments, you cannot have any of the same team mates. This forces you to work with different people each time, which means that when assignments overlap on the timeline, then you'll have to juggle between the different groups. Feels like 3 courses in 1, just in the first 6 weeks.\nAfter the 6 weeks, it was the final project, where you either work with an external organisation, or work on your own project. This assignment I didn't survive. I got so behind on my deliverables, that I kinda abandoned my team mates entirely. I fessed up to the prof, and he was understanding, but I still fairly got a B. I think I deserved it, as I didn't really put in the effort for the final project.\nSo if you want to take this course, be prepared to put in the effort. It's not a course where you can slack off, as the deliverables are extremely high. Perhaps the highest out of all the courses in SoC (other than maybe CS3233). Otherwise, in all fairness, it's a top tier course.",
    "fairness": 4,
    "retention": 5,
    "grindable": 1,
    "usefulness": 5
  },
  "CS3219": {
    "title": "Software Engineering Principles and Patterns",
    "semester": "AY24/25 S1",
    "grade": "A-",
    "review": "The mod is all about software design. The first half is about the planning phase. This includes gathering requirements, understanding the business needs of the software. This leads to domain-driven design and event storming, which is all about breaking down the problem into different parts that we can group, categorise, arrange, and convert into code components. The second half talks about patterns in software architecture, with focus on object interactions, message and data patterns. Though some may seem trivial, I think the lectures do a good job at introducing us to different ways things can be done. Different ways will have different trade offs, and many times, there will be more than one viable solution, depending on the context and constraints of the system.\nVague AF requirements. That pretty much sums up the mod. Seriously. 90% of the anxiety in the mod stems from understanding what the project actually wants from us. But I guess that's a key learning point of this mod. in the real world, you're not gonna get all the requirements fed to you. You need to ask the right people for clarification. In this case, we could've just asked the prof for clarification on marking points. The profs encourage us to just email them when we encounter an issue. Don't solely rely on TAs.\nThat said, the project portion was excruciatingly heavy. It was to build PeerPrep, a platform for students to practice technical interview questions together. That's the core functionality of the project, which required us to develop a matching and a collaboration feature. But of course that's not all. They gave us 12 different bonus features to add to the project. From this list, we were to pick at least 4-5 of them to work on. Most of them were not trivial either. Some involved deployment on cloud platforms including gateway, CI/CD etc. Some involved adding audio and video calls to the collaboration space. Some involved adding an AI assistant, language translation, code execution, and many more. The graders have a checklist of what to look out for when grading your project. Hidden functionality that are not explicitly stated but you're expected to include in your project. As such, always be thoughtful of what you add or exclude.\nThe most important thing is to document whatever discussion you may have with your groupmates. Key decision points, like why you chose to do option A over option B. For example, if option B was the way that the profs wanted you to do, then you can at least show in your report that the team has discussed it and decided to go with option A for whatever valid reason. Without this documentation, it is an easy missed mark.",
    "fairness": 2,
    "retention": 4,
    "grindable": 3,
    "usefulness": 4
  },
  "CS3223": {
    "title": "Database Systems Implementation",
    "semester": "AY23/24 S2",
    "grade": "B+",
    "review": "Ah another B+ course for me. This course suffers the same fate as my CS2100 and CS2106. It is a VERY computational-heavy course, with lots of arbitrary calculations here and there. You are the computer. Be the computer. But then again, it is a pre-requisite for many of the other database courses, so you have no choice but to take this.\nThe content is so dry and so boring. It has little to do with SQL, and more to do with data structures and performance. You start off learning about B-trees, which allow the database to store data in a sorted manner. You go through how to search for specific data, how to evaluate queries, and how to rebalance the tree after insertions and deletions.\nAfter B-trees, the next big topic is Hashing, either linear or dynamic hashing. In this topic, you focus more on how to build your index from scratch. The difference between the linear and dynamic hashing is quite significant, so it's best to fully understand them before moving on.\nThen, you move on algorithms like handling SELECT, PROJECT, MERGE and JOIN. But instead of being explanation questions, their significance comes in the middle section of the course.\nThe entire middle section is dedicated to query optimisation and performance evaluation. When running these queries, the database can evaluate them using different strategies. Using different indices, reshuffling the search queries, those are some of the things the optimiser change do to figure out the optimal strategy. And guess what? That's your job too! You are the computer. Be the computer. Do all these calculations yourself and see what answers you get! The big thing you need to be able to count is the number of disk I/Os done by your program, which basically means how many times your code reads from memory. This one metric leads to so much pain. So many conditions, so many calculations.\nThe final section is a little more of a break. It's all about concurrency control. Basically how you make sure that data is always correct, yet allow many processes to access it at once. You can use locks, you can use timestamps, you can use scoped locks. All valid ways of implementing concurrency control. Much more straightforward than the computation questions, but still pretty dry and difficult.\nWorkload is more on the consistent side. Every week, you have to present your answer at least once. This means you can't show up to the tutorial empty-handed. You must prepare your answers beforehand. All that for 3%, which is not worth IMO. I probably got my B+ because of my finals, which had a lot of concepts that I didn't know very well.",
    "fairness": 3,
    "retention": 2,
    "grindable": 4,
    "usefulness": 1
  },
  "CS3230": {
    "title": "Design and Analysis of Algorithms",
    "semester": "AY22/23 S1",
    "grade": "A",
    "review": "This is one of the killer courses in the CS core curriculum. Pretty much no coding is involved; the entire course is ffull of proofs and pseudocode. We need to prove why a certain algorithm works, and why it is the most optimal solution to a problem. There is also heavy emphasis on modifying algorithms, which means how to use the solution to one problem to solve another. This is a pattern you'll see time and time again, as many of the problems you'll find here are just the ones you already know, just in disguise. The course starts off with more advanced complexity analysis, be it asymptotic or probabilistic. There's lots more math involved here, and you'll often have to solve recurrence relations to get the right runtime complexity. Something like T(n) = T(n-1) + O(1).\nThen, you'll move on to the different kinds of hashing algorithms (universal, uniform etc), all of which was tested for the midterms (I scored okay).\nThe second half of the module was a little more interesting, as we built up different families of algorithms. First, we had the classic Dynamic Programming, where we use recursion and memoisation to build up our solution space. Then for Greedy Algorithms, it's all about making the best decision at each step, and hoping that it leads to the best overall solution. Next, we have Incremental Algorithms, which is all about how to update our solution when new data comes in. Lastly, we have Linear Algorithms, which mainly focused on how to formulate a problem into a series of linear relations. Given a particular problem, you'll need to quickly identify which family of algorithms you need to use, and then modify them to suit your needs.\nThe last few lectures go through reducibility and NP-completeness. These are more for further studies, but are still useful to know. They are very theoretical in nature, and quite abstract so be warned. They basically talk about whether a particular problem is considered computationally hard. Basically remember how Cardinality works in CS1231S. It's the same concept, trying to find relations between the two algorithms and seeing if they are computationally equivalent. But if you don't fully get it, it's fine, as it doesn't matter too much in the industry anyway.\nIn terms of workload, it was quite small during my semester. It was just a weekly problem set, of which only 3 were graded for accuracy. The rest were graded just for effort, so we pretty much only had the midterms and finals to worry about.",
    "fairness": 4,
    "retention": 3,
    "grindable": 2,
    "usefulness": 2
  },
  "CS3231": {
    "title": "Theory of Computation",
    "semester": "AY24/25 S1",
    "grade": "A",
    "review": "You are the computer. Be the computer.\nThis course is about building logical machines that can solve problems. In particular, the main focus is to build a machine that tells us whether a string should be accepted or rejected. For example, we may want to accept strings with an equal number of a's and b's, where this set of strings is called a language. For this, we need one of many machines you will learn throughout the course.\nThe simplest is a Finite Automaton, which functions like a state diagram. It reads a string letter by letter, moving through the different states based on predefined state transitions. We can then know whether to accept the string based on which state the machine lands on after reading all the letters. These machines are pretty weak, as the strings they can accept must be able to be represented as a regular expression like ab*a.\nThat's why we have more powerful machines like context free grammars (which generates the language via a tree-like structure) and pushdown automata (which store memory in a stack).\nFinally, the most advanced machine is the Turing Machine, which can theoretically solve any problem.\nI'd say there are 3 kinds of questions. The first kind is about creating these machines given a certain language. Define how they work, and give a brief proof that they work.\nThe second kind is about proving whether a certain language is regular, context-free, decidable, etc. There's quite a number of different techniques to do this, so lots of exposure to questions will help greatly here. Get ready to get your lemma pumped, if you know what I mean.\nThe third kind is very theoretical, as it talks about hypotheticals. For example, what if we had a machine that could solve the halting problem? What would happen? These types of questions are the hardest, as they require a lot of inspiration and creativity. You need to really cook to get this within the time crunch. So best to avoid answering them.\nThis brings us to workload. Actually moderate, as you have to do and submit your tutorial online every week. Marked by effort, so don't worry too much. What does matter is the tutorial itself, where Prof will ask you to write your answer on the board. No avoiding this, as 10% of your grade is tutorial participation. And the Prof is brutal too, and will make you feel stupid. It's actually quite effective, as it encourages you to put in effort to your tutorials. So don't be scared of him. He's actually a nice guy.\nFor assessments, there is CA1, CA2, and the finals, so it's actually a lot to revise. The best thing is that the questions are hard, yet the Prof marks them leniently. That, to me, is the best combo, as most of the time, you will get a pleasant surprise when you get back your papers. As long as Prof thinks you know what you're talking about, he'll give you benefit-of-the-doubt marks. Goated marking style.",
    "fairness": 5,
    "retention": 3,
    "grindable": 3,
    "usefulness": 1
  },
  "CS3245": {
    "title": "Information Retrieval",
    "semester": "AY23/24 S2",
    "grade": "A",
    "review": "The course is about designing indexes to help people get the right information they need, similar to what Google Search Engine does. We start off building the simplest bigram models, which counts the frequency of 2-character sequences in a document. They help to identify the document, enabling us to search for it later (I want a document containing 'Bi' and 'is').\nWe then move on to more complex models like Boolean Retrieval and Postings Lists. Boolean retrieval is a method of information retrieval that uses Boolean logic (AND, OR, NOT) to match documents containing specified keywords (I want a document containing 'Bishan' and 'Resident'). Posting lists, on the other hand, make the boolean retrieval process faster, allowing us to merge queries together to reduce the search space (eg there is a difference in evaluating ('A' AND 'B') AND 'C' vs 'A' AND ('B' AND 'C')).\nAfter that, we have tolerant retrieval, which basically allows us to search for close but not direct matches, using techniques like prefix searches and wildcard queries (I want a document containing *mon).\nThe next topic is about index construction and compression, which is about how to store the index in a way that is both space-efficient and time-efficient. We learn about how to store the index in a way that allows for fast retrieval, but also allows for fast updates. This is a very tricky balance, as the more space-efficient the index is, the slower the retrieval time, and vice versa.\n Then comes the Vector Space Model, which is the main bulk of the course. The Vector Space Model is a way to represent documents as vectors, and queries as vectors, and then to find the most similar document to the query. If the document vector is similar enough to the query vector, then it will be returned as a result. The later topics all reinforce this model, like improving it with relevance feedback and query expansion.\nIn terms of workload, I'd say it's pretty high. There are 4 Homework Assignments in total, and they are pretty long. Performance is extremely important here, as you will be graded mainly on how accurately your search engines return the correct documents. There's alot of tweaking involved, and you have to be pretty comfortable with working with Python and file descriptors. The finals were not too bad, and they're quite manageable. Just be sure to know your concepts well, and you should be fine.",
    "fairness": 4,
    "retention": 3,
    "grindable": 3,
    "usefulness": 2
  },
  "CS4211": {
    "title": "Formal Methods for Software Engineering",
    "semester": "AY24/25 S1",
    "grade": "A",
    "review": "Utter garbage. Nothing much to comment about the teaching style, as I didn't come for them past the first lecture. But the content itself was awful. In a nutshell, the mod is about defining the behaviour of a system, rather than designing the system itself. We do this using 3 new languages:\nZ language looks most like math, and it focusses on defining invariants, transitions, object types, domains, and schemas. This language is actually pretty good, and I wish we got more of this, but alas, there are 2 more.\nThe second language is Communicating Sequential Processes (CSP), which talks about states, events, and processes. It introduces us to Linear Temporal Logic (LTL), which are assertions about the system that must hold through, such as 'After event A happens, then condition B must hold indefinitely'.\nThe final language is RTS (can't even find it online), which is like CSP but now we include time, such as waits, timeouts, etc.\nIn terms of workload, it can be very fast, but to get all correct, you need a lot of time discussing with others. 3 homeworks on Canvas, for each of the languages. One finals. One project. Let's talk about them separately.\nFinals was undoubtedly the best part among the three. MCQ in person on Canvas. 100% based on what's taught in the mod, and the question wording was pretty clear. It's quite a fair exam.\nBut all that falls flat for the rest of the mod. See, apparently, NUS created something called Process Analysis Toolkit (PAT), which is a software that supposedly checks whether your model is valid. But,\n1: it only runs on Windows, so a Mac user such as myself found it excruciating to partition your Mac to run Ubuntu and eventually Windows. Absolutely pain to do this process. And some more it's needed to complete your assignment and project. \n2: PAT may claim to be used widely in the industry. But who??? There's little support online for debugging PAT, only a single documentation site that's honestly not very good. \n3: And for what?? Learn how to use PAT just for this mod? That ain't right. \n4: It's absolutely easier to code up these systems than using PAT to model them.\nFk the project honestly.",
    "fairness": 4,
    "retention": 0,
    "grindable": 1,
    "usefulness": 0
  },
  "CS4225": {
    "title": "Big Data Systems for Data Science",
    "semester": "AY23/24 S2",
    "grade": "A-",
    "review": "This course is all about Big Data and the tools we can use to deal with them. The first part throws in a lot of new terminology and definitions at us. Like how we can measure the performance of a data pipeline, or measure how much space we need.This led up to the Map Reduce model, which makes up a pretty substantial part of the course. Map Reduce is like a pipeline, where data is passed through a series of functions, and each function does a little bit of processing on the data. The data is then passed to the next function, and so on. This is a very powerful model, as it allows us to process data in parallel, which is very important when dealing with large datasets. Questions they may ask are about designing the right functions to pass into the Map Reduce model, and how to ensure that the data is processed correctly. IIRC this whole part was the Hadoop part, which is the more traditional approach to dealing with big data.\nThe more modern one would be Spark, which takes away the need to manage everything with a master worker. Instead, the code becomes much simpler and more human-readable. The code becomes more iterative,so you can chain together operations to get the result you want. Spark is also where you'll find our real-time data processing, and how we manage synchronisation issues between the different worker nodes.\nThe end section deals with how we can use this data to come up with insights. Concepts like Machine Learning, page ranking and graph algorithms will be thrown about, but now in a new light. Now, we design our big data systems to support these algorithms. I quite liked this part as it's the more problem-solving part.\nThe workload is pretty low, just 2 assignments with 1.5 month deadlines. It's really easy and it takes about 30 minutes to complete each assignment. Though, they are VERY heavy at 25% each, so it's best to wait around before submitting your work, in case you have any careless mistakes.\nAm I right in what I've babbled about? Probably not, as I don't really remember much from the course, and probably why I only got an A-. Or maybe the bell curve was actually that high? Who knows.",
    "fairness": 2,
    "retention": 2,
    "grindable": 1,
    "usefulness": 2
  },
  "CS4243": {
    "title": "Computer Vision and Pattern Recognition",
    "semester": "AY23/24 S1",
    "grade": "B+",
    "review": "The course is obviously about Computer Vision and Pattern Recognition. The first half is all about image processing, which is about how to manipulate images to extract certain features. We start off with the basics, like how to convert an image to grayscale, how to apply filters to an image, and how to detect edges in an image. We learn things like convolution, fourier transforms, and signal processing, all building to our intuition on how we can process the image. There is also motion detection, where we use two still images to determine the relative speed of an object in frame. These are all very basic concepts, but they are the building blocks for the more advanced topics later on.\nOf course, as an AIML course, the fun doesn't stop there. We will now try to train the computer to extract and identify these features for us. Lots of image recognition use cases in here. But the part that doesn't quite sit right is the heavy emphasis on the really low-level AI concepts. Concepts like perceptrons and backpropagation are reiterated again in this course. But why though? Weren't they already covered in previous courses like CS2109S? It just felt like a good 3 weeks was wasted relearning the CS2109S concepts.\nThe workload was pretty low for the most part, around 3 take-home assignments with like one month to complete them. Even though they were lab assignments, we don't actually need to submit any code. Instead, we were given a Canvas MCQ quiz to input our answers. There was simply no room for error, which sucks because the MCQ questions are all very unclear and tricky. I probably lost a few marks there.\nOther than that, there is tutorial attendance, where you only need to appear for 7/10 of the tutorial classes to get the full marks for attendance. A bit waste time, since the TA is only there for consultation and doesn't actually give any structured tutorials.\nThe final project involved creating an image classification model, which detects whether there is or isn't a weapon present in the image. To be honest, I was feeling a little down at this point in time, so I didn't contribute much to the project. At the start, yes, but nearing the end, I was just lost in every meeting. The final deliverable for the project is a poster and a presentation. The poster should be designed to be informative and you will be presenting based on the poster. No slides required.\nThe finals were full of tricky questions, and very unclear phrasing and instructions. It was troublesome, and probably why I ended up with a B+. Can't deal with unclear questions.",
    "fairness": 2,
    "retention": 3,
    "grindable": 4,
    "usefulness": 3
  },
  "CS4347": {
    "title": "Sound and Music Computing",
    "semester": "AY24/25 S1",
    "grade": "A+",
    "review": "Prof is so chill and open to feedback. Definitely one of the most goated teaching teams in SoC.\nThis mod may be put in the media focus area, but it certainly is HEAVY on deep learning concepts. Automatic Speech Recognition (ASR) and Music Transcription (AMT), audio analysis and synthesis, are some of the core topics covered. You'll also have to think in terms of the frequency domain, as you'll work with fourier transforms (converting signals into the frequency domain), and spectrograms (how frequency components change over the course of the audio clip). You'll learn about different music formats, mainly working with MIDI for the most part.\nYou'll need a strong understanding of how they work, because they will become the building blocks for your deep learning models. Cos dimensions are always a painful thing to reason with for any model.\nThere is a heavy emphasis on class participation, as even lecture attendance is expected. And you should. Cos Prof invites external speakers to talk about their areas of expertise. They are pretty good and Prof Wang Ye is very particular about who he invites.\nI think the most effort put in by the teaching team was organising the concert near the middle of the semester. For extra participation points, you can perform a piece of music in front of the CS4347 audience. If you can, then you are encouraged to do so. I can't perform directly, so I proposed to arrange one of the pieces. I still got the points anyway. Free food, free concert, goated Prof. Some more it came from his own pocket, so all the thanks to him.\nWorkload was reasonable for the importance of the concepts taught. I think Prof values thoughtfulness and effort over anything else, so keep this in mind when doing the assignments.\nA1 was a critique on one of Prof Wang Ye's past papers. For this, you need to discuss summary, strengths, weaknesses, and your own personal take on it. Try to be unique and you'll get a high score.\nA2-4 are labs based on the lecture. A2 is on fourier transforms, A3 on AMT, and A4 on ASR. They are HEAVY, but nothing too out of the ordinary. Half the points are for the code and results, while the other half is for the write-up, which are like short-paragraph-response-questions. The labs are pretty well done, though I feel too much deep learning knowledge is assumed.\nA5 is about writing a project proposal and video. For this, make sure you fully know the rubrics, as the proposal is graded based on that and not really on quality. From there, you get to network on the day of the concert to find your groupmates. Do a project relating to S&M Computing, can be research, software, anything. Then write a report, do a video presentation, and you're done. No finals!",
    "fairness": 2,
    "retention": 4,
    "grindable": 3,
    "usefulness": 4
  },
  "GEA1000": {
    "title": "Quantitative Reasoning with Data",
    "semester": "AY21/22 S2",
    "grade": "A",
    "review": "For STEM students, this course is one of the biggest waste of times. It teaches how to analyse and interpret data, using techniques like hypothesis testing and plotting charts. I appreciate that NUS has pushed this for all students, but come on. We are already covering these topics in our core mods like ST2334.\nWorkload is nearly non-existent, as most of the time, you only have to do a couple of Canvas quizzes. There are also tutorials every 2 weeks, where most of the time is dedicated to group discussions anyway. The project was just a simple data analysis project with Excel, which was relatively easy to do. There was also a final presentation, where we had to interpret the results of a research paper, and apply the concepts that we've learnt in the course. Don't worry too much about it.\nBut what you do have to worry about are the exams. The questions are not hard at all, and can be completed in 5 minutes in theory. But realistically, they are very unclear what exactly they are looking for, and the phrasing of the questions is awful. Only 10 questions some more. Could be done in 5 minutes, but the 60 minute time is for you to gaslight yourself into thinking you're wrong. It would honestly be better for them to add more questions (maybe 20) so that we don't have to worry so much about gaslighting ourselves.\nOverall, I appreciate the course for non-STEM students, but if you're in CS, it's better for you to take ST1131, as it actually teaches you R, much better for learning data analysis.",
    "fairness": 2,
    "retention": 3,
    "grindable": 3,
    "usefulness": 2
  },
  "GEC1030": {
    "title": "Metropolis: City in World History",
    "semester": "AY21/22 S2",
    "grade": "A-",
    "review": "Haiya I put too much effort into this course but still A- only. The course is all about the different ways cities are important to societies. Be it cultural, political, economical, or technological, cities around the world become popular for different reasons. Lots of case studies are given, including Manchester, London, Edo, Angkor Wat, Istanbul, Amsterdam and Melaka, each revolving around a particular theme.\nThere were many profs teaching this course, each talking about their city of expertise. There's basically no lectures, but instead all content is recorded beforehand. It's quite nice to watch actually, as the profs are quite passionate about their cities of interest. This is a fact that they keep bringing up in tutorials as well, as my tutor keeps talking about his home city, to give us a clearer example of the concepts.\nThere are 4 assignments in total, and with tutorial participation, these make up the entirety of your grade. No exam. The first assignment is about selecting a picture of a city and writing a summary about it. What does the picture say about the city? What concepts can you pick up from the lectures? Those types of questions.\nThe second assignment was a documentary critique. They give you around 4 documentaries for you to choose from, then you watch it and write around 600 words about it. The documentaries are like those you'd find on History channel, around 1 hour each. For the critique, you HAVE TO write about both the positives and the negatives. What did the documentary capture accurately about the city? What did they leave out? How does this lead back to the lectures? Why is this documentary significant or insignificant? Don't just applaud it. It's a critique for a reason.\nThe last two assignments are basically just one. It is a creative works assignment, which means you have to create a piece of literature about a city of your choise (no, it can't be Singapore). You have quite a few options to pick from. You can choose to do up a poster, a personal recount, a narrative, a travelogue/travel guide. Quite a lot of freedom. But remember, you always have to link back to the content in the lectures. You are given 1500 words in total. If you're writing a short story, then it's 600 words for the story and 900 words for the write up. Be sure to add lots of references to your work, as they help add credibility.",
    "fairness": 2,
    "retention": 3,
    "grindable": 1,
    "usefulness": 2
  },
  "GESS1019": {
    "title": "Urban Planning in Singapore",
    "semester": "AY21/22 S1",
    "grade": "A-",
    "review": "The course is about the history of urban planning in Singapore. It goes through the ideas that past pioneers have envisioned for the perfect city, and how they have been implemented in real life. Think about big European figures like Ebenezer Howard and his Garden City movement, or the unique development of Milton Keynes. Theoretical concepts are quite intuitive and make sense. For example, quite a bit of emphasis is placed onto decentralisation of activity, which means that different activities should be spread out across the city, so that people don't have to travel too far to get to where they want to go. This is a concept that is quite prevalent in Singapore, as we have many different town centres, each with their own unique identity.\nThe lectures go through quite a lot of Concept Plans and Master Plans in Singapore, which are essentially the blueprints for how Singapore should be developed. The Concept Plan is the more high-level plan, which talks about the general layout of the city, and where the major developments should be. The Master Plan is the more detailed plan, which talks about the specifics of the city, like where the roads should be, where the parks should be, and where the residential areas should be.\nNot too difficult to understand, but memorising all these different plans becomes quite challenging. Because you need to give these as examples in the exams. The finals are just essay-based questions, very much like those you'd find in Econs. If you don't have decent general knowledge of developments in Singapore, then I think you'll have a tough time coming up with your answers and examples. But if you have a rough understanding of what is happening in Singapore, then you should be fine.\nWorkload is quite low, just a couple of tutorial participation points, and a group project. For the group project, you are to identify an urban planning problem in Singapore, and come up with a PW-like solution for it. A simple report and presentation. My group decided to do a project on Hawker Centres and how to get more young people to eat there. There was also two groups which did theirs on urban heat sinks, so the scope can be pretty much anything.\nI'm quite lucky I got this course, because I really can't imagine myself taking the others. This one is much safer and more enjoyable.",
    "fairness": 3,
    "retention": 2,
    "grindable": 1,
    "usefulness": 2
  },
  "GEN2002X": {
    "title": "Total Defence Project Against Threat to Community",
    "semester": "AY23/24 S2",
    "grade": "A-",
    "review": "This course is a big waste of time. I'd say the biggest learning takeaway from this course is the persistent emphasis on resilience. Resilience is not about prevention of a certain threat. Instead, resilience talks more about how we can recover from a threat, and how we can adapt to the new normal. This is a very important concept, as it is very hard to prevent all threats from happening. Instead, we should focus on how we can recover from them, and how we can adapt to the new normal. Types of resilience would include social resilience, economic resilience and most importantly, psychological resilience.\nTypes of threats would include a lot of cyber threats, regional political instability, pandemics, climate change, and lots and lots of fake news. These types of threats are discussed time and time again in each tutorial and lecture, recontextualising them based around a kind of resilience.\nThat's pretty much all we learned in the course.\nWorkload is quite low. For the first sem, it was mostly the tutorials you had to worry about, since there is tutorial participation points. As usual for a GEM mod, everyone is mostly quiet except for the few loud and opinionated individuals. There is a reflection you need to do, but most of your time will be spent on the project, where you have to do a mid-term presentation and proposal. Be careful who you get as the audience. There was an individual who speaks with a major lisp, and no one could understand a single word he said. Yet, he was the one asking Q&A questions, which makes the whole thing so frustrating.\nThe second sem is much more lax, as there is only one presentation you have to do in person. The rest of the sem is just free. But the problem is that, the presentation slot is 4 hours, and it takes up an awful spot in your timetable. So even though it was only one day, good luck trying to plan your schedule around that one day.\nThankfully, I got an A-, though I pretty much deserved much lower at a B or B+. Yay I didn't need to SU.",
    "fairness": 3,
    "retention": 0,
    "grindable": 1,
    "usefulness": 1
  },
  "ES2660": {
    "title": "Communicating in the Information Age",
    "semester": "AY23/24 S2",
    "grade": "A-",
    "review": "This course is not as waste time as I thought, and I think your experience with it would depend on your tutor. To sum it up, this course is about how to talk and argue with people.\nBreaking it down, first we have Critical Thinking. Critical Thinking is like the ability to think about things in a logical and rational way. We are taught quite a few different frameworks on how to piece together our arguments. The Toulmin model is a framework for analysing and constructing arguments, consisting of six components: claim, grounds, warrant, backing, qualifier, and rebuttal, which together help to support and justify the argument. The Ennis framework is a model for teaching and assessing critical thinking, emphasising the development of skills such as identifying and clarifying issues, evaluating evidence, reasoning logically, and making well-supported judgments. The Paul and Elder model is a framework for critical thinking that includes elements such as clarity, accuracy, precision, relevance, depth, breadth, logic, significance, and fairness, organized into three main components: intellectual standards, elements of reasoning, and intellectual traits to cultivate disciplined, analytical, and fair-minded thinking. I think this was the most important part of the course, as one of the assignments is to make your own critical thinking framework and turn it into a presentation as our CA1. My team and I didn't do so well on this, but I think it's still okay.\nThe second part of the course is about persuasion. How to take your argument and convince others that what you're saying is true. Feels kinda duh, but it really isn't. The tutor gives lots of exercises for us to try out, all leading up to CA2. For CA2, we are to take an article and do a commentary about it (about 600-850 words). Talk about the implications, and give lots of your own opinions. A word of advice: don't just praise the article entirely. But rather, try being Uncle Roger for once and nitpick on the small details and nuances, as well as the big ones. The topic for my sem was 'Human Agency in AI', and I wrote about Google GraphCast.\nThe final assignment CA3 is a wildcard assessment. Basically, each person is given a random prompt about technology or other topics and they give a quick 2 minutes presentation about it. You get 5 minutes to prepare, and in that time you can do as much Googling/ChatGPTing as possible. But once the timer is up, try to present without looking at any notes or phone. Try to string the arguments as fluidly as you can, but don't worry about making it perfect. They are looking for structure, content and delivery, so try to hit all three decently well, and not just one or two.\nAs for workload, my sem was pretty lax with only 3 CAs (as compared to the 5 CAs in previous sems). Tutorials are only three hours, once a week, so that's the best it gets. Easy to plan around a schedule since there are so many slots you can take.\nAs I've mentioned before, your experience in the course depends heavily on your tutor and how engaging they are. My tutor was quite engaging, so I think I did quite well in the course. I think I deserved the A-, and I'm glad I didn't need to use my SU for this course.",
    "fairness": 2,
    "retention": 2,
    "grindable": 3,
    "usefulness": 2
  },
  "LSM1301": {
    "title": "General Biology",
    "semester": "AY24/25 S1",
    "grade": "A-",
    "review": "This mod is just information overload every lecture. It starts off with microbiology, talking about organic chemistry, cells, energy, and genetics. Then the second half talks about more macrobiology stuff like evolution, taxonomy, plants, animals, and ecology.\nYou will learn at least 50 new words every lecture, as the profs try to cram as much content in a short amount of time. A good thing is that you don't have to remember most of them, as the exams allow full access to your notes, so you just need to know where to find information.\nIn terms of content, I find macrobiology easier to reason with, as it works with things we are generally familiar with. More specifically, it is easier to use logic and real world understanding to understand why certain things are the way they are. Micro on the other hand is just painful. There are many diagrams that help illustrate what goes on, and I appreciate that. But there's just too many concepts spread very widely that it's hard to keep up.\nWorkload is actually medium, as the prof decided to have 2x in-lecture quizzes worth 5% each. Because of this fact, it means I have to come to school every Monday at 8am. If this is still the case when you take it, if you're taking the mod with a friend, you can just take turns showing up for the lecture, as all you have to do is to share the quiz questions with each other.\nBesides the quizzes, there are 4x2h labs throughout the semester. They are actually quite strict on the marking, so as a CS student who dk and dc how to fill up a lab report, it made me lose marks here and there. \nExams were just 2x40 questions MCQs during lectures, which are CA1 and CA2. CA1 tests Micro, while CA2 tests Macro. Open book. The time limit is actually very tight, so don't waste time on questions u don't know. Just guess and move on.",
    "fairness": 3,
    "retention": 0,
    "grindable": 3,
    "usefulness": 1
  },
  "MA1521": {
    "title": "Calculus for Computing",
    "semester": "AY21/22 S1",
    "grade": "A",
    "review": "I think this is a pretty good refresher course for math. The course covers quite a lot of fundamental concepts in calculus, including limits, functions, sequences, series, and differentiation.\nLimits talks about the behaviour of a function as it approaches a certain point. We do mainly two things here. Prove whether a limit exists, and compute the value of the limit. The questions based around the former tend to be a little more tricky, as the types of functions they use are much more complex. On the other hand, for computing the value of the limit, the questions are pretty much standard, so you don't need to worry about it much.\nSequences and series talks about whether a pattern of numbers converges or diverges. There are like 8 convergence tests that you need to learn and practice. You need to know when to use each one, and how to apply them properly. I'd say this is the most challenging part of the course, as the questions can be quite tricky as well.\nLastly, we have functions. Sounds simple at first glance, but can get quite complicated. It mainly deals with whether functions are continuous or differentiable. It also brings us into the world of multivariate calculus, as we learn how to expand these theorems to the xy plane. Quite fun actually.\nAs for the workload, there was no compulsory attendance, but with 2x2h lectures and 1x1h tutorials every week. The only thing is that there are three in-lecture tests, which were not well-monitored at all. I think this module was a little poorly executed, because of the lack of anti-cheat measures. But it really feels like the professor cares about his students, so he really did try his best.\nThat's it for the exams, as there is no finals. Quite a low-effort course, especially compared to CS1101S.",
    "fairness": 3,
    "retention": 2,
    "grindable": 3,
    "usefulness": 2
  },
  "MA2001": {
    "title": "Linear Algebra I",
    "semester": "AY21/22 S1",
    "grade": "A-",
    "review": "This course is all about linear spaces, focussing on the more computational aspects of it. How to define a linear space, how to find eigenvectors, how to find the basis vectors etc. The concepts accumulate gradually over the course of the semester, so maintaining a steady pace is quite important here. You can't easily skip lectures and expect to be on track all of the time. You will be exposed to a lot of different matrices and related concepts, so I think creating a sort-of mindmap will work better here as compared to other courses.\nNot sure how it is these days, but in my sem, we had to work with MATLAB for our computational tasks. With unconventional syntax and poor debugging, it was torture.\nWorkload is pretty low, as is most math courses. You have tutorial attendance, a few assignments, and exams. But if you're a CS student, you might have a little trouble dealing with the bell curve, as you'll be competing against the Math majors. Call it copium, but I think the reason I didn't get my A- was because of the bell curve. That, and the fact that there was lots of construction going on outside my window, so I couldn't concentrate on my exams. Pick an excuse haha.\nOverall, I think the inclusion of this course is quite significant, as it gives a good foundation for learning ML and AI. That's probably what MA1522 is for, but I'm not sure what that course fully is haha.",
    "fairness": 5,
    "retention": 3,
    "grindable": 4,
    "usefulness": 4
  },
  "MA2101": {
    "title": "Linear Algebra II",
    "semester": "AY22/23 S1",
    "grade": "A",
    "review": "Similar to MA2001, this course talks all about linear spaces. However, this time, the concepts are much more abstract. We rarely see numbers, but instead, we see lots and lots of unreadable notation. There are lots of powerful theorems in this course, and you have to apply them masterfully in your proofs.\nThe first 8 topics were mostly recaps of MA2001 topics. Concepts like isomorphism, transformations, basis vectors. But now, we don't really deal with any numbers, but instead we are taught their theorems. I'd say that if you're struggling with this part of the course, then the course is not for you haha.\nBecause the rest of the course is just... So much content. Chapter 9: Eigenvalues. It is already bigger than the first 8 chapters combined. Same goes for Chapter 10: Jordan Canonical Forms and Chapter 11: Inner Products and Bilinear Forms. The content is so dense, with a new powerful theorems being thrown out every page of the lecture notes. I honestly thing the pacing of the course is off, as the first half feels so empty, while the second half feels so full. It would do good if the prof speeds up the first half, as that part doesn't really matter too much.\nWorkload is relatively high for a math mod, as there are 5 graded assignments, compulsory tutorial attendance, and two exams. The assignments are quite difficult, owing to the difficulty of the course itself. It can take a few tries to get the optimal proof for submission, but I think overall they are quite fair. The finals were abnormally easy, as the questions were quite straightforward and standard. But I think other sems were much more difficult, with more tricky questions and non-standard answers.\nI wasn't expecting an A at all, but I think that just goes to show that the bell curve for this course is much better than that of MA2001.",
    "fairness": 4,
    "retention": 1,
    "grindable": 2,
    "usefulness": 1
  },
  "MA2104": {
    "title": "Multivariable Calculus",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "This course is all about working in the 2D and 3D space. It deals with the behaviour of different functions, including continuity, differentiation, vector fields.\nContinuity and differentiation talks about whether a surface is smooth or not. We deal with Lagrange multipliers, which basically deals with the gradient of a function. With this, we can find the local minima and maxima of the function, and from there, we can solve all kinds of optimisation problems.\nThe second half of the course is all about vector fields. This is a very Physics-related topic, as it deals with lots of concepts like divergence, curl, and line integrals. These are all very powerful concepts, and they can be used to solve a wide variety of problems. These are some of the hardest to draw diagrams for, as you'll be trying to draw 3D figures. But try your best, okay? It's important to visualise the problem, as it can help you solve it much more easily.\nWorkload is very low. Tutorial attendance is not compulsory, and there are only a few graded assignments. There is of course the exams, which has the potential to be deadly. Since the topic is quite grounded in reality, expect a few real-world problems to be thrown in. But overall, I think the course is quite manageable, and I think I deserved the A.",
    "fairness": 4,
    "retention": 3,
    "grindable": 4,
    "usefulness": 3
  },
  "MA2108": {
    "title": "Mathematical Analysis I",
    "semester": "AY22/23 S1",
    "grade": "B+",
    "review": "This module is basically proving stupidly obvious things, and coming up with overly complicated solutions to simple problems. For example, one of the first few proofs we learnt is how to prove that x^2=3 has a positive solution. It sounds very duh, like even a PSLE student can tell you that. But the formal proof for it takes up around 2 pages. If there's one major thing I've learnt from this, is that you DON'T ASSUME ANYTHING. Forget all you currently know about math, because all that doesn't matter. ONLY USE THE THEOREMS THEY GIVE YOU. There's no shortcuts, no simpler way to do things. This is as bare-bones as it gets.\nWorkload is quite low, with just a few assignments and a midterm and finals. The problem is that the bell-curve is so incredibly high for this course, that even the simplest mistake will send you to the shadow realm. I wished so hard for a conventionally difficult paper, but all I got was a simple yet tricky one. I practiced so hard for this course, but come out so simple questions. Hence the B+ haiyaaa. My first non-A grade in my history with math, and it hurts haha.\nAs for my overall thoughts, I find the lecturer to be quite bored and boring. He had little control over this one student who keeps interrupting him. Voice is soft and unconfident, and he doesn't really engage with the class. But I think the content was structured well-enough so no complaints there.",
    "fairness": 2,
    "retention": 3,
    "grindable": 3,
    "usefulness": 0
  },
  "MA3236": {
    "title": "Non-Linear Programming",
    "semester": "AY23/24 S1",
    "grade": "A",
    "review": "This course is all about solving non-linear optimisation problems. Mostly quadratic ones, but you'll occasionally have the trigonometric or exponential functions. To put it simply, you solve problems like these by finding the minimum or maximum of a function, given a set of constraints. The course starts off with the basics, like what a feasible region is, and how to prove that a function is convex (using Hessian Matrices). Then, we learn how to find the optimal solution for an unbounded problem. We then move on to more advanced topics, like how to find the Lagrange multipliers, and how to solve the KKT conditions. These are all very powerful concepts, and they can be used to solve a wide variety of problems.\nThe problem is that these processes are so long and convoluted, all to solve a simple problem. For example, first you need to find the gradient of the function, then you need to find the Hessian matrix, then you need to find the eigenvalues of the Hessian matrix, then you need to find the Lagrange multipliers, then you need to find the KKT conditions. It's a very long and tedious process but luckily, your answers are more verifiable, as the solutions are actually simple just by doing some accurate diagram drawings.\nWorkload is normal, with a few assignments, and exams. The questions are all about applying the concepts and processes properly. All pretty standard questions that as long as you can follow the instructions on your cheatsheet, you should be okay. I'm quite satisfied with my A.",
    "fairness": 4,
    "retention": 3,
    "grindable": 3,
    "usefulness": 2
  },
  "MA3238": {
    "title": "Stochastic Processes I",
    "semester": "AY23/24 S1",
    "grade": "A-",
    "review": "There are two courses on Stochastic Processes. This first one deals with discrete events, while the second one deals more with continuous events. In this discrete version, we mainly deal with Markov Chains, modeling all our problems using matrices. We start off with the basics, like what a Markov Chain is, and how to represent it using a transition matrix. We then move on to more advanced topics, like how to find the steady-state distribution of a Markov Chain, and how to find the period of a system. There's lots of computations that you need to do in this course. You'll be constructing many matrices, where even the slightest error would mean your entire question is wrong. Lots of attention to detail is required, and you'll need to be fast with your calculations, as time is short during exams.\nThis course is very close to real-life, so a LOT of the questions will be geared towards modeling a real life scenario. For example, one of the midterm questions deals with a train onboarding passengers. Another one deals with rooms in a house, where the person travels at random around the house. Converting these scenarios into matrices is the most important skill to have here. It's a real-life skill you need to have, modeling real-world problems in terms of math.\nWorkload is normal for a math mod, as there are a few assignments, tutorial attendance, and exams. I stopped coming for tutorials some time in the sem, so maybe that's why I didn't get my A hahaha.",
    "fairness": 4,
    "retention": 3,
    "grindable": 3,
    "usefulness": 2
  },
  "MA3252": {
    "title": "Linear and Network Programming",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "This courses is all about solving linear problems. In 3D space, this means finding the most optimal point on a particular polyhedron.\nWe first learn how to model the problem in terms of linear equations and inequalities. This creates our polyhedron. From here, we apply something known as the Simplex Method, which is a systematic way to solve a system such as this. There's quite a lot of edge cases you need to be aware of, such as degeneracy, unboundedness, and infeasibility. These are all very important concepts, and you'll need to be able to identify them quickly, as they can affect the way you solve the problem.\nThe next part of the lecture deals with Duality theorems. Basically, when solving a linear problem, you need to strive for two things. Firstly, your solution needs to be feasible, which means it obeys all the constraints you give. Secondly, your solution needs to be optimal, which means it is the best solution you can get. Essentially, the conventional Simplex method will ensure that your solution is always feasible, and we just need to nudge it to be an optimal solution, On the other hand, the dual method will ensure that your solution is always optimal, and we just need to nudge it to be a feasible solution. You need lots of practice with the two methods, as they are both important for the next topic.\nCombining what you've learnt so far, you'll be able to solve sensitivity analysis problems. This topic deals with understanding how the optimal solution changes when you change the coefficients of the problem. For example, if you shift this constraint, how does the solution change? On the other hand, if you change the objective function, how does the solution change? For this, you'll need to run the Simplex or the Dual Simplex method a few times to find your answer. Your job is to find out which one.\nThe question design is very based in the real-world, so you'll need to master the art of mathematical modeling. Identify the constraints, objective function, and variables, and you'll be fine. No non-standard questions, but just be sure to be accurate with your calculations, as the questions are quite long and tedious.\nOtherwise, workload is fine, with a few assignments, and exams.\n\n\n\n\n\n\n\n\nOh did I forget about Network Programming? Yes (in Uncle Roger voice).",
    "fairness": 3,
    "retention": 2,
    "grindable": 2,
    "usefulness": 3
  },
  "ST2334": {
    "title": "Probability and Statistics",
    "semester": "AY21/22 S2",
    "grade": "A+",
    "review": "The first half of this module is basically revision for topics taught in JC; it focusses on the fundamentals of probability and basic combinatorics. However, at the middle of the module, the difficulty ramps up quite drastically. They were manageable topics, but can get lost if you don't follow the lecture; it goes into the various hypothesis tests and integration techniques.\nHowever, the most frightening thing about this module was the format of the final exam. It prevented backtracking, so we couldn't return to a previous question once past it. This led to absurd time management tactics, leaving me with 30 minutes to solve the last 2 questions (out of 35).\nIf coding scripts are available for future exams, then be sure to abuse them as much as possible. For my finals, I prepared my Python script to answer basically any question they throw at me, so all I needed to do was use the right one for the job.\nOtherwise, figure out which topics are new to you, and you can safely skip the lectures for the rest of them.",
    "fairness": 3,
    "retention": 3,
    "grindable": 5,
    "usefulness": 3
  },
  "IS1103": {
    "title": "Ethics in Computing",
    "semester": "AY21/22 S2",
    "grade": "A+",
    "review": "Absolute waste of time. Take if you want to pull your hair out for no reason whatsoever. Everyone ages 20 years when taking this module.\nThat aside, the content is common sense, but the questions are designed to make you question your sanity every week. Be prepared to examine all interpretations of every question, only to get the question wrong in the end.\nAnd I absolutely learned nothing from this, as I, until now, still don't know WTF a negative and positive right is.\nDon't take this if you don't need to. It's a waste of time.",
    "fairness": 0,
    "retention": 0,
    "grindable": 0,
    "usefulness": 0
  }
}