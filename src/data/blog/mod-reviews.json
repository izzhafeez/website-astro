{
  "CFG1002": {
    "title": "Career Catalyst",
    "semester": "AY22/23 S2",
    "grade": "CS",
    "review": "CFG1002 is a 2MC course which can be completed in one afternoon. If you need feedback points for CourseReg, CFG1002 is a good way to get them. There's also some lecture you have to attend nearing the middle of the course, but otherwise, there's basically no workload. If you're planning on taking it for the content, here's the breakdown:\n1. Resumes and Cover Letters.\n2. Personal Branding.\n3. Interviews.\n4. Networking.\nThe content itself may seem quite simple, but it actually builds certain intuitions that are hard to develop otherwise. Don't assume you know everything about it, because there are quite a number of small details that can make a big difference. Here's the breakdown of the completion requirements:\n1. Passing grade on Canvas Quizzes.\n2. Set up accounts on ConnectUS and IAAS.\n3. Elevator Pitch on VMock.\n4. Resume submissions on VMock (you have to get a passing score).\nOverall I think it's a good course to take and finish during the first week of school. They give you everything at one shot, so why not finish this while the workload for your other courses is still low?"
  },
  "CFG3001": {
    "title": "Career Advancement",
    "semester": "AY23/24 S1",
    "grade": "CS",
    "review": "CFG3001 is a 2MC course which can be completed in a week. This is a good source of feedback points if you need them for CourseReg. It is pretty similar to CFG1002, but it focusses on different things. In particular, it emphasises the need for a personal brand, and discusses more advanced tips on how to network properly. Concepts like VIPS will be thrown around often, as a sort of framework for self-analysis. That said, the workload may be a little higher than CFG2001:\n1. Canvas Quizzes.\n2. conNectUS Profile setup, and you have to do a forum response.\n3. Set up an informational interview with someone in the industry (you need to show proof that you did it).\n4. Jot down what you learnt from the informational interview in a reflection journal.\n5. Use the VIPS framework to analyse your own skills.\n6. VMock interview practice.\nMost of them were fine, but the one that sizzles my spring onions is the VMock interview. It requires you to turn on your camera, then VMock will analyse your facial features (whether you're smiling, looking away, body language etc). But the thing is, my face is dark, so VMock was having a very hard time detecting my face. It took me a few tries to even get it to start the interview. Turning up the light, moving closer, changing angles, until I got the right combination of all. Goes to show how biased the facial recognition is. But I digress. Overall, I think it's a good course to take, especially if you're planning to go for internships or jobs soon. It's a good way to get your feet wet in the industry."
  },
  "CP2106": {
    "title": "Orbital (Independent Software Development Project)",
    "semester": "AY22/23 S1",
    "grade": "Artemis",
    "review": "Orbital is something that many year ones will take during their summer break. For those of us who didn't manage to get an internship during our first year, this Orbital programme is a good second alternative.\nIt's pretty much a pair-work course, as you and your partner will have to create one sophisticated project from start to finish. If you're struggling to find a partner, Reddit is always a good option. That's how I found mine.\nNext, let me explain the different levels of Orbital. Before the development period commences, teams can decide to go for different achievement levels. They are a good gauge of how complex you want your project to be, indicative of the amount of effort you want to put in, and decides what requirements you will have to meet to pass the course. I took the Artemis level, the highest level you can achieve in this course. While there are some fixed requirements such as code reviews, testing and promotional videos, the rest of the requirements are more... subjective. In other words, your TA has the ultimate say whether you belong in that achievement level. Which means that if you get a sadistic TA, you will have to work extra hard to maintain your achievement level. Luckily, I managed to get a pretty chill TA who found our application suitable enough for Artemis level. From there, the requirements become more relaxed, as we move from Artemis, to Apollo, to Gemini, and finally to Vostok. The bulk of the teams opt for Gemini, as there is not much difference from a Vostok level.\nIt's hard to gauge how much effort to really put into the different grading requirements. I think I may have gone a bit overboard with the software engineering practices. I did WAY too much testing, including unit tests, integration tests, system tests, performance tests and more. I also did WAY too much documentation, including my 81-page final Orbital report. Surprisingly, it didn't take too long, but still, 81-page is no joke. Don't really have a benchmark on how much you should do, but just know that you have to convince your TA that you're doing enough.\nThe rest is up to you. Build anything you want, as long as it's related to software. Can be a robotics project, can be a game, can be a web application. From seeing past submissions, the best project award always goes to some game, because it is immediately obvious how much effort was put into it. By adding more game mechanics, you can easily make your game more complex and sophisticated, earning more points on that aspect. But if you want to make it easier for people to test your project, please make it a web application and deploy it on some site like Netlify. Don't make it a mobile application and expect people to use it on Expo Go. The next time I have to open up Expo Go, I'm gonna give that a bad review.\nOverall, I think if you can find an internship in your first year, then you should do that instead. But if can't, then this project is a good first step."
  },
  "CP3200": {
    "title": "Student Internship Programme I",
    "semester": "AY23/24 S1",
    "grade": "CS",
    "review": "SIP I is usually taken in your Y2 summer break, based on the MC requirements set by SoC. It's a 12-week internship, and you have to work full-time. Besides the internship workload, however, there isn't that much that you need to do.\nFirstly, if the internship was not found using NUS TalentConnect, you have to instruct the company to post a listing on the platform. After a few email exchanges back and forth, you should be able to apply for that role under SIP I. If not, then please inform the necessary people that you are unable to do it. Don't leave it to the last minute.\nBut it's pretty much straightforward from there. At the start, you write down your initial objectives, which basically states what you plan to learn and accomplish during your internship. Afterwards, you have to submit monthly reports to monitor your progress through the internship. The big thing you have to worry about comes at the end, where you have to submit a Final Report, which is about 2000 words long. If you've been doing your internship properly, then this report shouldn't take too long to write. There is also an internship presentation with your SIP TA. Nearing the end of your internship, just book a 15-minute slot with your TA in the evening and just present. Don't be stressed about this, as it's quite an easy presentation if you've actually been doing work in your internship."
  },
  "CS1101S": {
    "title": "Programming Methodology I",
    "semester": "AY21/22 S1",
    "grade": "A",
    "review": "Please don't take the exemption from this course. It is absolutely necessary. CS1101S is the first computing course you will take as a CS student. If you're not in SoC, you would be taking some variant on CS1010 instead. The difference here is that CS1101S is taught in a JavaScript-like language, while CS1010 is mainly taught in more traditional languages like Python and C.\nThis course is one of the biggest time sinks in your first semester. The workload is notoriously heavy, thanks to the gamified platform that the course administrators have kindly prepared for us. Source Academy. It keeps track of all our course-related materials, and uses XP to determine how many marks we get for that component. Basically everything gives XP. Tutorial participation, homework, quizzes, and many more optional content. Don't worry, you won't need to score full marks to clear this component. As long as you maintain a decent XP score for each compulsory assignment, then you should be able to clear this component quite easily. Most people do, anyway.\nBesides the practical exams, the midterms and finals heavily test you on data structures like lists, pairs and streams. But the one that drains my rice is the Environment Model, which is basically tracking how many function calls are made in a program. There's a lot of arbitrary definitions in place, with not a lot of room to practice. Build the intuition by looking at many examples. I learn best when I have lots of positive or negative feedback for my answers, which was pretty hard to get here. So I reworded many of the definitions to language that I can understand."
  },
  "CS1231S": {
    "title": "Discrete Structures",
    "semester": "AY21/22 S1",
    "grade": "A+",
    "review": "This course is the first introduction to rigorous math. The main focus is on proving techniques, and the different types of proofs that you can use to prove a statement. If you don't come from a math-intensive background, this course may be the bane of your existence. Some people find this course fun and interesting, and some people will curse and swear at this even up till graduation.\nThe course starts rather simply, teaching the basics of logic and logical inferences. Then we slowly build up our intuition on sets, relations, functions, trees and graphs. But the truly painful part of the course comes after the recess week. Cardinality. Cardinality basically deals with the size of sets. Given set A and its relationship with set B, what can we say about the size of set B? Based on the question design, this can get very confusing very easily. As such, one good tip is to see how many marks the question gives you. If it's high, then you're likely expected to give a full proof for it. If it's relatively low, then the answer is likely much more straightforward than you're thinking. This narrows down your options quite a bit, so don't overlook it.\nOverall, nailing down the fundamentals of proving is extremely important, as you'll be needing it later down the road when taking CS2040S and CS3230. And of course, if you're taking any math mods, then this is basic knowledge. No way around it."
  },
  "CS2030S": {
    "title": "Programming Methodology II",
    "semester": "AY21/22 S2",
    "grade": "A+",
    "review": "Ah welcome to the world of Java. This course teaches the two programming paradigms: Object-Oriented and Functional. We start off the first 2 weeks learning about types and declarations. The next 4 weeks sees OOP concepts like inheritance, polymorphism, and encapsulation. Out of the earlier concepts, the stack and heap model really tears my tofu like paper. It basically represents where different things are stored in memory. Your variables, your functions, all captured in stack frames or dumped on the heap. Drawing the arrows to connect the different components was absolute pain, and I got 1/8 for that question in the Midterms. With no feedback loop to practice, this was expected. My midterms were in the bottom 25 percentile.\nObviously the second half of the semester was where I did my best. Functional Programming, and the beauty of Monads. What is a monad? Well, a monad is a monoid in the category of endofunctors, which states a few basic rules that it needs to follow. With those basic guarantees, we can compose different functions together to achieve the result we want. Pretty abstract, but also where I excel at.\nIn terms of workload, I'd say CS2030S has a much higher workload than CS2040S. The weekly labs are done on SoC servers, which means you need to be comfortable with working in the Vim code editing software. Using the mouse is not recommended in Vim, and you need to learn basic navigation skills like how to quit Vim. The lab content was fine. You have to implement some functionality in Java, like Optional or Try types. Basically what you've learnt in the lectures, but in a more practical setting. Boring as heck, but still manageable. You will have all these test cases that determine your score for the lab. The thing is, you are not given all the test cases, only the public ones. This means that you have to make sure you cover all edge cases so that you can pass all the private test cases as well. Furthermore, you need to use the concepts that they taught ie there is an intended way to do it, and you are marked based on your compliance to that way. This is essential for nailing the Practical Exam, which I got full marks for."
  },
  "CS2040S": {
    "title": "Data Structures and Algorithms",
    "semester": "AY21/22 S2",
    "grade": "A",
    "review": "Probably the most important course for technical interviews. This is a crash course on all things algorithms. The course starts off with the basics of complexity analysis, then moves on to sorting algorithms, searching algorithms, tree algorithms and finally graph algorithms.\nBe prepared to spend a lot of time on the sorting algorithms, as there are like 6 of them. You have to know what each of them does, what are their invariants, and what conditions are best for them. Put these all in your cheatsheet and you should be fine.\nFor complexity analysis, you are mainly dealing with loops and recursions, so take note of how many loops there are, and how many times the loops run. A rule of thumb would be:\n1. If you're in a loop and the variables are incrementing by a fixed amount, then think linear O(n).\n2. If you're in a loop and the variables are changing by multiplication or division, then thing O(logn).\n3. If you're using recursion and calling f(n-1) twice, then think exponential O(e^n).\n4. If you're using recursion and calling f(n-1) once, then think linear O(n).\n5. If you're using recursion and calling f(n/2) a fixed number of times, then think logarithmic O(logn).\nTree algorithms are very error-prone, as there are so many different edge cases you need to worry about. The AVL tree, for example, is a self-balancing tree, which means that when things are added or deleted, the tree needs to be able to rearrange itself to not let any side be too long. Remembering and coming up with the edge cases is not a easy task.\nLastly, for the graph algorithms, the star of the show is the Dijkstra algorithm. It's the most famous out of them, but with a little tricky implementation. It's a valuable algorithm to learn and master.\nAs for workload, we use the Coursemology platform, which gives score based on the amount of XP you earn from homework and tutorial participation. Again, you don't need to worry so much about getting full XP for everything, as most people get it anyway. Homework is usually solving some algorithmic problem, and you use the different data structures and algorithms you're learnt to solve them. They're all in Java, so it is typically recommended to take this course alongside CS2030S. I usually finish the problem sets within 2 hours of the release, so it's not too bad. I'm usually one of the first ones to submit their work, which means I usually get my XP very early on, easily putting me near the top of the leaderboard week after week.\nThe midterms and finals are pretty manageable, as they test you on your problem solving skills. Be prepared to write lots of pseudocode and draw lots of diagrams. Don't waste time writing curly braces or writing type declarations, as these all will slow you down. Instead, just focus on writing the core structure of the algorithm IN PENCIL, and if you have time after completing the questions, then you can go back and fill in the details. What they are testing you on are your concepts, and NOT your knowledge of Java syntax. So don't worry too much about that."
  },
  "CS2100": {
    "title": "Computer Organisation",
    "semester": "AY22/23 S1",
    "grade": "A-",
    "review": "The course has a very unique progression. It starts off in C programming, teaching fundamentals like addresses and memory management. Then, we drill down to the bare bones of logic and electrical components. So from C, we go down to assembly language (human-readable instructions for the machine), then to machine code (1s and 0s), and finally to logic components. From there, we slowly build up our circuit components, achieving more complex functionality like Adders and Multiplexers. Just know that you'll be dealing with a lot of logic diagrams to figure out how to design your circuit. This was the fun part. Circuit design.\nBut the last 3 weeks really colanders my rice. Process Scheduling is about calculating how long a sequence of instructions will take to execute. It's not a simple task, as each instruction is composed of many stages, which are handled in different parts of the machine. The execution of these stages can be done concurrently, which leads to awfully long and convoluted calculations. Memory management, on the other hand, was a little more manageable, but was still very pain. It's about how the computer caches data, and how it can be optimised to reduce the time taken to access data. Lots of calculation to see how much time is saved, and how much of the cache is actually used.\nExpect exam questions to have a lot of arbitrary calculations. That is, calculations that you have NO WAY of knowing whether you are right. The worst kind of questions for me. No intuition involved, just following instructions. You are the computer. Be the computer.\nThat said, the workload isn't very high, just a bunch of low-effort labs that can be done in 5 minutes. It's just a mountain of content you need to get through."
  },
  "CS2101": {
    "title": "Effective Communication for Computing Professionals",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "This module is a good starter pack for soft skills. Though it may seem as fluff for most people, I think it's not. We computing students don't really have any soft skills, especially as compared to other majors like Business. We don't have that high of a tutorial participation weightage, and lectures don't have any participation marks. Which makes this course one of only two computing mods that actually teaches soft skills. This course is twinned with CS2103T, which means that your team for CS2101 and CS2103T will be the same. Make sure you get good and reliable teammates, as you'll be stuck with them for 8MCs worth of courses.\nContent-wise, I actually find the topics and discussions quite helpful. It heavily encourages us to speak up more during lessons, as tutorial participation is quite high. We are encouraged to share our answers with the class very often.\nAs for workload, it's a little on the heavier side, as we have 2x2h tutorial slots every week, which makes it a little difficult to plan your schedule around. But other than that, it's quite a low-effort course. Your grade is heavily influenced by how much your tutor favors you, so be sure to be memorable in class and participate a lot. As for specifics, you will have two presentations (one on a career-related topic, and one about your CS2103T project), the User Guide from your CS2103T project, and two reflections. That's pretty much it. With reliable teammates, it's quite manageable."
  },
  "CS2102": {
    "title": "Database Systems",
    "semester": "AY22/23 S1",
    "grade": "A",
    "review": "This module is not all about SQL. Maybe just the first half is. The first half teaches about SQL queries and schema, and the difficulty ramps up with each lecture, so be sure to not skip any of the fundamentals. It starts off with simple select statements, but you'll eventually add more and more syntax like WHERE, JOIN, GROUP BY, HAVING, and more complicated ones like CTE, subqueries, recursion and functions. These later ones are the mind-blowing ones, as they are not what you'd typically associate with SQL. But they are still somewhat useful to know. Just make sure your earlier topics are solid, as most places would likely need that level of SQL understanding.\nThe second half is about designing your database. Each database needs to store many different fields. This chapter is about how you group these fields into different tables to ensure certain guarantees. These is all under normalisation, which is formalised using algebraic notation, quite simple to understand actually.\nAs for the workload, it's quite low honestly. You work in groups of 4 to create an ER Model (which is basically a diagram of your database), then you have to create a database with SQL functions. The second assignment was significantly more difficult, because it is quite hard to debug SQL code without a mock database. But other than that, there is one tutorial presentation you have to do and nothing much else.\nThe midterms was a little tricky, as you have to write working SQL code to perform certain queries. That in and of itself isn't too hard, but the time crunch definitely makes it feel like an actual PE. The finals was a little more standard, as it was more about your theory concepts, and how you apply normalisation rules to design your database."
  },
  "CS2103T": {
    "title": "Software Engineering",
    "semester": "AY22/23 S2",
    "grade": "A+",
    "review": "This module teaches proper software engineering techniques and processes. The primary language is in Java, but you'll also learn Git for version control and Markdown for documentation.\nLots of diagrams like sequence, class, object and activity diagrams. These help to explain how your code works to someone new to the codebase. Lots of notation and conventions you have to follow and memorise. You will always see these types of questions in the finals. All the small details, all the minor nuances in the notation that you have to pick up and determine whether they are right.\nLots of Git theory was taught as well, how to branch, how to pull request, how to merge conflict, how to do CI/CD, how to use the Issue Tracker. All very basic skills that all of us need to know in the industry.\nAll this leads to the projects. There are two main projects that you'll be doing during the semester.\nThe first is the Individual Project (IP), which tasks to make a to-do list with specific functionality. The requirements are given to you week-after-week, and your progress is tracked through GitHub and shown on a leaderboard. The objective of this IP is to get you familiarised with Java and the Git workflow, which is helpful as we don't want people messing up the Team Project (TP).\nThe TP is where you'll spend a good 7 weeks on. You are given the code for an Address Book written in Java, and you're supposed to revamp it to add more functionality. Add more features, beautify the application. Those kinds of things. The requirements are quite open-ended, so you can do whatever you want. Just make sure that you sufficiently test your code, as it is very important for the Practical Exam (PE).\nBasically, in the PE, you will have to test the code of other teams, and find bugs in their code. The more bugs you find, the higher the score you'll get. At the same, if the code that your team wrote has many bugs, then you'll lose the points. So, don't develop a massive codebase that you can't fully test.\nBut then again, this goes in conflict with CS2101, which requires you to 'sell' your product to the class. So, you have to balance between making your product look good, and making sure it works well. It's a tough balance, but it's a good experience to have.\nOverall, I think this module is a good introduction to software engineering. A good baseline for the number of lines of code to contribute is 2k, leading to a 10k line codebase for the group. These figures are tracked on the dashboard, so you can easily see what others are up to. In the end, I contributed over 18k lines of code, so I was quite happy with my performance."
  },
  "CS2106": {
    "title": "Introduction to Operating Systems",
    "semester": "AY23/24 S1",
    "grade": "A-",
    "review": "Wah this one pain. This course is all about the OS. How it manages its CPU, memory, and processes. The first part is all about how the OS schedules tasks on the CPU. Then we learn how the OS manages different threads to run concurrently. Those parts are relatively okay, just need to know the relevant C code.\nAfter that though... hais... We have lots of memory issues. Different processes need to communicate with each other, which means they either use shared memory or have to rely on message passing. Basically, either they share a mailbox, or have a mailman transfer mail between the two mailboxes. The mailman is of course the OS. We need to implement this in the labs, using pipes in C, which allows processes to talk to each other.\nBut wait, there's more. By enabling concurrency, we introduce a lot of new problems. This is synchronisation, something we need to do to ensure that the correctness of the program is maintained. In C, we are taught to do this using semaphores, which are basically locks that you can put on a resource. If you have the lock, then you can access the resource. If not, then you have to wait. This is a very tricky concept, as you have to ensure that you don't deadlock.\nIn terms of workload, I'd actually say that it's not very high. There are just 4 labs. Sure, they may take a while to grasp, but once you understand the requirements, the implementation itself isn't that hard. Probably took me 4 hours per lab to complete. Not that bad.\nBut I think I died in the exams. It's again my worst exam format, testing minute details and small nuances. The calculation questions aren't too good either, as getting one number off will get you no marks. My concepts aren't great either, as I didn't really understand the material too well. As such, I think I got a little lucky with the grade, as I was expecting a B or B+."
  },
  "CS2108": {
    "title": "Introduction to Media Computing",
    "semester": "AY22/23 S2",
    "grade": "A",
    "review": "The course is all about signal processing and how to compress data. This is pretty important in the real world, as we need to be able to send data over the internet quickly and efficiently. The first part is all about the Fourier Transform, which basically converts signal data from the spatial/time domain into the frequency domain. Lots of math, but the prof emphasises that you mainly need to understand the concept and no need to prove or be able to derive the math. The course teaches us that high frequency components are relatively hard to detect, so even if we remove them from our signal, we can't really tell the difference. This makes a huge difference in image processing, as our eyes can't really detect pixel-to-pixel differences, but we are able to tell when a large portion of the image is distorted or warped.\nThis is the basis for the JPEG compression algorithm, which takes out most of these high frequency components and compresses the image. I'd say that is the biggest part of the course.\nOf course, there are many more smaller compression algorithms, like the LZW, Run Length Encoding and the famous Huffman Coding, which all have their strengths and weaknesses. These are algorithms that you have to know by heart, as cheatsheets are not allowed in this course. These algorithms are the ones that you can and have to do manually. You are the computer. Be the computer.\nIn terms of workload, it's quite low. You are basically implementing certain algorithms using MATLAB. Around 6 MATLAB worksheets in total, to accomplish tasks like convolution and fourier transforms. MATLAB is also one of the most unintuitive languages to learn. They start their index at 1, and use round brackets for indexing. Very weird, and you'll never get used to it."
  },
  "CS2109S": {
    "title": "Introduction to Machine Learning and Artificial Intelligence",
    "semester": "AY22/23 S2",
    "grade": "A+",
    "review": "The course is all about classical concepts in both AI and ML. In AI, the focus is about problem formulation. How we analyse a given problem and how we come up with conditions that the solution has to meet. This led to the A* algorithm, which improves upon the Dijkstra Algorithm but now we know where we want to go. We can use this knowledge to narrow down our search, leading to much faster discovery of the optimal solution. The second half of the course is all about ML, which means lots and lots of math. We stared at a lot of partial differentiation, and gradient descent formulas. Some past students complained that this course had too much math, while some of them complained that there was too little math. I think in the end, the course struck a good balance between the two extremes. Sure, the ML concepts were hard, but hey, they weren't tested as there were no finals anyway.\nAs for workload, it's all in Python, so if you're quite comfortable with Python and its associated libraries like Numpy, you should be fine. It's quite similar to CS2040S, where you have to implement algorithms and submit them on Coursemology for XP. The second half is where you'll be exposed to PyTorch, which is a machine learning library that is quite popular in the industry. You'll start off implementing things like gradient descent, and eventually you'll come round to actually building models and pipelines, using datasets to train them. All this culminates in the final practical exam, which is a 2-day Kaggle-like competition where we all have to build models based on a dataset given to us, then they would run on their servers and scores will be given based on the accuracy of the model. I did decently well for this competition, hence leading to my A+."
  },
  "CS3211": {
    "title": "Parallel and Concurrent Programming",
    "semester": "AY23/24 S2",
    "grade": "B+",
    "review": "I thought I would survive this course, but nope B+. It is a pretty tough courses teaching concurrency paradigms in three languages, being C++, Go and Rust. 6 weeks are dedicated to learning concurrency in C++, which can be done in multiple ways. The straightforward way is to use locks, which restricts access to certain resources. The more advanced way is to use atomic variables and functions. These are variables and functions that can be accessed by multiple threads at the same time, without any locks. This is a very powerful concept, but also very error-prone. You have to be very careful with how you use these atomic functions, as they can lead to very hard-to-debug errors. This topic is often merged with Memory Order, which determines how the CPU reorganises instructions to optimise the code. In a very strict mode, the CPU is not allowed to do much reshuffling of machine instructions, leading to a very predictable, yet sequential execution. The more relaxed we go, the more we allow the CPU to reshuffle its instructions, which can lead to faster execution. Of course, with reshuffling, it's your duty as the programmer to ensure that the code remains correct. This means certain key relations between variables must be maintained, using the Memory Order concept to help us reason with this behaviour.\nMoving on to Go, we mainly use channels to communicate between different Goroutines (aka your different tasks). Channels allow you to pass any kind of data between two tasks. You can send over numbers, strings, structs and even other channels. Very versatile and allows for a more modular approach to concurrency. The thing you need to worry about during implementation is how to close all of the Goroutines. Who is going to coordinate everything?\nLastly, we have Rust, and the main concept here is asynchronous programming. This feels like a pipeline, where data is passed from one task to another, and each task needs to fully complete using await before it is passed to the next one.\nDon't understand my explanations? It's okay. I don't understand them either. The course is full of high IQ people, I can't compete with them. I'm just a lowly CS student. But I think I did okay for the course, all things considered. I think I just did consistently average for the three assignments as well as the finals, leading to the expected B+.\nBy the way, the assignments were really tough. One for C++, one for Go and one for Rust. All extremely hard to debug, and hard to understand. Easily spent 4 times the time on this than I ever did with CS2030S or CS2040S."
  },
  "CS3216": {
    "title": "Software Product Engineering for Digital Markets",
    "semester": "AY23/24 S1",
    "grade": "B",
    "review": "This course is not your typical CS course. Instead of teaching CS, this course teaches the product development process. The prof doesn't teach much, but instead invites external speakers every week to share more about their industry. The first few were about UX Design and how to gather user pain points and requirements. Some lessons were about idea-generation and how to transform bad ideas into good ones (basically the mindset behind idea-generation). There was also a lesson on understanding team-dynamics, where we had an exercise to understand each other's strengths and weaknesses, workflow and behaviours. There were also quite a few startup-related lessons, including how to raise money, and how to scale up the business.\nAssignment 1 required us to produce a working prototype of our solution to a problem. It can be any problem, as long as we are able to conduct the necessary research and interviews to validate our solution. This involes the entire design iteration process, starting with identifying pain points, target audience, conducting interviews, conducting user testing and usability testing. So much user testing.\nAssignment 2 was about researching a real-world Generative AI product and present it to the class. We were tested on how well we could 'sell' the product, as well as how in-depth our evaluation of the product was. Don't be overly supportive of the product, and be sure to give the negatives as well.\nAssignment 3 was abou creating an application surrounding a certain Generative AI model. It can be anything, but the main feature has to be Gen AI. My team did ChitChatChampion, which is an online ice-breaker platform powered by GPT. This was the only assignment I was confident in.\nNote that for the first three assignments, you cannot have any of the same team mates. This forces you to work with different people each time, which means that when assignments overlap on the timeline, then you'll have to juggle between the different groups. Feels like 3 courses in 1, just in the first 6 weeks.\nAfter the 6 weeks, it was the final project, where you either work with an external organisation, or work on your own project. This assignment I didn't survive. I got so behind on my deliverables, that I kinda abandoned my team mates entirely. I fessed up to the prof, and he was understanding, but I still fairly got a B. I think I deserved it, as I didn't really put in the effort for the final project.\nSo if you want to take this course, be prepared to put in the effort. It's not a course where you can slack off, as the deliverables are extremely high. Perhaps the highest out of all the courses in SoC (other than maybe CS3233). Otherwise, in all fairness, it's a top tier course."
  },
  "CS3223": {
    "title": "Database Systems Implementation",
    "semester": "AY23/24 S2",
    "grade": "B+",
    "review": "Ah another B+ course for me. This course suffers the same fate as my CS2100 and CS2106. It is a VERY computational-heavy course, with lots of arbitrary calculations here and there. You are the computer. Be the computer. But then again, it is a pre-requisite for many of the other database courses, so you have no choice but to take this.\nThe content is so dry and so boring. It has little to do with SQL, and more to do with data structures and performance. You start off learning about B-trees, which allow the database to store data in a sorted manner. You go through how to search for specific data, how to evaluate queries, and how to rebalance the tree after insertions and deletions.\nAfter B-trees, the next big topic is Hashing, either linear or dynamic hashing. In this topic, you focus more on how to build your index from scratch. The difference between the linear and dynamic hashing is quite significant, so it's best to fully understand them before moving on.\nThen, you move on algorithms like handling SELECT, PROJECT, MERGE and JOIN. But instead of being explanation questions, their significance comes in the middle section of the course.\nThe entire middle section is dedicated to query optimisation and performance evaluation. When running these queries, the database can evaluate them using different strategies. Using different indices, reshuffling the search queries, those are some of the things the optimiser change do to figure out the optimal strategy. And guess what? That's your job too! You are the computer. Be the computer. Do all these calculations yourself and see what answers you get! The big thing you need to be able to count is the number of disk I/Os done by your program, which basically means how many times your code reads from memory. This one metric leads to so much pain. So many conditions, so many calculations.\nThe final section is a little more of a break. It's all about concurrency control. Basically how you make sure that data is always correct, yet allow many processes to access it at once. You can use locks, you can use timestamps, you can use scoped locks. All valid ways of implementing concurrency control. Much more straightforward than the computation questions, but still pretty dry and difficult.\nWorkload is more on the consistent side. Every week, you have to present your answer at least once. This means you can't show up to the tutorial empty-handed. You must prepare your answers beforehand. All that for 3%, which is not worth IMO. I probably got my B+ because of my finals, which had a lot of concepts that I didn't know very well."
  },
  "CS3230": {
    "title": "Design and Analysis of Algorithms",
    "semester": "AY22/23 S1",
    "grade": "A",
    "review": "This is one of the killer courses in the CS core curriculum. Pretty much no coding is involved; the entire course is ffull of proofs and pseudocode. We need to prove why a certain algorithm works, and why it is the most optimal solution to a problem. There is also heavy emphasis on modifying algorithms, which means how to use the solution to one problem to solve another. This is a pattern you'll see time and time again, as many of the problems you'll find here are just the ones you already know, just in disguise. The course starts off with more advanced complexity analysis, be it asymptotic or probabilistic. There's lots more math involved here, and you'll often have to solve recurrence relations to get the right runtime complexity. Something like T(n) = T(n-1) + O(1).\nThen, you'll move on to the different kinds of hashing algorithms (universal, uniform etc), all of which was tested for the midterms (I scored okay).\nThe second half of the module was a little more interesting, as we built up different families of algorithms. First, we had the classic Dynamic Programming, where we use recursion and memoisation to build up our solution space. Then for Greedy Algorithms, it's all about making the best decision at each step, and hoping that it leads to the best overall solution. Next, we have Incremental Algorithms, which is all about how to update our solution when new data comes in. Lastly, we have Linear Algorithms, which mainly focused on how to formulate a problem into a series of linear relations. Given a particular problem, you'll need to quickly identify which family of algorithms you need to use, and then modify them to suit your needs.\nThe last few lectures go through reducibility and NP-completeness. These are more for further studies, but are still useful to know. They are very theoretical in nature, and quite abstract so be warned. They basically talk about whether a particular problem is considered computationally hard. Basically remember how Cardinality works in CS1231S. It's the same concept, trying to find relations between the two algorithms and seeing if they are computationally equivalent. But if you don't fully get it, it's fine, as it doesn't matter too much in the industry anyway.\nIn terms of workload, it was quite small during my semester. It was just a weekly problem set, of which only 3 were graded for accuracy. The rest were graded just for effort, so we pretty much only had the midterms and finals to worry about."
  },
  "CS3245": {
    "title": "Information Retrieval",
    "semester": "AY23/24 S2",
    "grade": "A",
    "review": "The course is about designing indexes to help people get the right information they need, similar to what Google Search Engine does. We start off building the simplest bigram models, which counts the frequency of 2-character sequences in a document. They help to identify the document, enabling us to search for it later (I want a document containing 'Bi' and 'is').\nWe then move on to more complex models like Boolean Retrieval and Postings Lists. Boolean retrieval is a method of information retrieval that uses Boolean logic (AND, OR, NOT) to match documents containing specified keywords (I want a document containing 'Bishan' and 'Resident'). Posting lists, on the other hand, make the boolean retrieval process faster, allowing us to merge queries together to reduce the search space (eg there is a difference in evaluating ('A' AND 'B') AND 'C' vs 'A' AND ('B' AND 'C')).\nAfter that, we have tolerant retrieval, which basically allows us to search for close but not direct matches, using techniques like prefix searches and wildcard queries (I want a document containing *mon).\nThe next topic is about index construction and compression, which is about how to store the index in a way that is both space-efficient and time-efficient. We learn about how to store the index in a way that allows for fast retrieval, but also allows for fast updates. This is a very tricky balance, as the more space-efficient the index is, the slower the retrieval time, and vice versa.\n Then comes the Vector Space Model, which is the main bulk of the course. The Vector Space Model is a way to represent documents as vectors, and queries as vectors, and then to find the most similar document to the query. If the document vector is similar enough to the query vector, then it will be returned as a result. The later topics all reinforce this model, like improving it with relevance feedback and query expansion.\nIn terms of workload, I'd say it's pretty high. There are 4 Homework Assignments in total, and they are pretty long. Performance is extremely important here, as you will be graded mainly on how accurately your search engines return the correct documents. There's alot of tweaking involved, and you have to be pretty comfortable with working with Python and file descriptors. The finals were not too bad, and they're quite manageable. Just be sure to know your concepts well, and you should be fine."
  },
  "CS4225": {
    "title": "Big Data Systems for Data Science",
    "semester": "AY23/24 S2",
    "grade": "A-",
    "review": "This course is all about Big Data and the tools we can use to deal with them. The first part throws in a lot of new terminology and definitions at us. Like how we can measure the performance of a data pipeline, or measure how much space we need.This led up to the Map Reduce model, which makes up a pretty substantial part of the course. Map Reduce is like a pipeline, where data is passed through a series of functions, and each function does a little bit of processing on the data. The data is then passed to the next function, and so on. This is a very powerful model, as it allows us to process data in parallel, which is very important when dealing with large datasets. Questions they may ask are about designing the right functions to pass into the Map Reduce model, and how to ensure that the data is processed correctly. IIRC this whole part was the Hadoop part, which is the more traditional approach to dealing with big data.\nThe more modern one would be Spark, which takes away the need to manage everything with a master worker. Instead, the code becomes much simpler and more human-readable. The code becomes more iterative,so you can chain together operations to get the result you want. Spark is also where you'll find our real-time data processing, and how we manage synchronisation issues between the different worker nodes.\nThe end section deals with how we can use this data to come up with insights. Concepts like Machine Learning, page ranking and graph algorithms will be thrown about, but now in a new light. Now, we design our big data systems to support these algorithms. I quite liked this part as it's the more problem-solving part.\nThe workload is pretty low, just 2 assignments with 1.5 month deadlines. It's really easy and it takes about 30 minutes to complete each assignment. Though, they are VERY heavy at 25% each, so it's best to wait around before submitting your work, in case you have any careless mistakes.\nAm I right in what I've babbled about? Probably not, as I don't really remember much from the course, and probably why I only got an A-. Or maybe the bell curve was actually that high? Who knows."
  },
  "CS4243": {
    "title": "Computer Vision and Pattern Recognition",
    "semester": "AY23/24 S1",
    "grade": "B+",
    "review": "The course is obviously about Computer Vision and Pattern Recognition. The first half is all about image processing, which is about how to manipulate images to extract certain features. We start off with the basics, like how to convert an image to grayscale, how to apply filters to an image, and how to detect edges in an image. We learn things like convolution, fourier transforms, and signal processing, all building to our intuition on how we can process the image. There is also motion detection, where we use two still images to determine the relative speed of an object in frame. These are all very basic concepts, but they are the building blocks for the more advanced topics later on.\nOf course, as an AIML course, the fun doesn't stop there. We will now try to train the computer to extract and identify these features for us. Lots of image recognition use cases in here. But the part that doesn't quite sit right is the heavy emphasis on the really low-level AI concepts. Concepts like perceptrons and backpropagation are reiterated again in this course. But why though? Weren't they already covered in previous courses like CS2109S? It just felt like a good 3 weeks was wasted relearning the CS2109S concepts.\nThe workload was pretty low for the most part, around 3 take-home assignments with like one month to complete them. Even though they were lab assignments, we don't actually need to submit any code. Instead, we were given a Canvas MCQ quiz to input our answers. There was simply no room for error, which sucks because the MCQ questions are all very unclear and tricky. I probably lost a few marks there.\nOther than that, there is tutorial attendance, where you only need to appear for 7/10 of the tutorial classes to get the full marks for attendance. A bit waste time, since the TA is only there for consultation and doesn't actually give any structured tutorials.\nThe final project involved creating an image classification model, which detects whether there is or isn't a weapon present in the image. To be honest, I was feeling a little down at this point in time, so I didn't contribute much to the project. At the start, yes, but nearing the end, I was just lost in every meeting. The final deliverable for the project is a poster and a presentation. The poster should be designed to be informative and you will be presenting based on the poster. No slides required.\nThe finals were full of tricky questions, and very unclear phrasing and instructions. It was troublesome, and probably why I ended up with a B+. Can't deal with unclear questions."
  },
  "GEA1000": {
    "title": "Quantitative Reasoning with Data",
    "semester": "AY21/22 S2",
    "grade": "A",
    "review": "For STEM students, this course is one of the biggest waste of times. It teaches how to analyse and interpret data, using techniques like hypothesis testing and plotting charts. I appreciate that NUS has pushed this for all students, but come on. We are already covering these topics in our core mods like ST2334.\nWorkload is nearly non-existent, as most of the time, you only have to do a couple of Canvas quizzes. There are also tutorials every 2 weeks, where most of the time is dedicated to group discussions anyway. The project was just a simple data analysis project with Excel, which was relatively easy to do. There was also a final presentation, where we had to interpret the results of a research paper, and apply the concepts that we've learnt in the course. Don't worry too much about it.\nBut what you do have to worry about are the exams. The questions are not hard at all, and can be completed in 5 minutes in theory. But realistically, they are very unclear what exactly they are looking for, and the phrasing of the questions is awful. Only 10 questions some more. Could be done in 5 minutes, but the 60 minute time is for you to gaslight yourself into thinking you're wrong. It would honestly be better for them to add more questions (maybe 20) so that we don't have to worry so much about gaslighting ourselves.\nOverall, I appreciate the course for non-STEM students, but if you're in CS, it's better for you to take ST1131, as it actually teaches you R, much better for learning data analysis."
  },
  "GEC1030": {
    "title": "Metropolis: City in World History",
    "semester": "AY21/22 S2",
    "grade": "A-",
    "review": "Haiya I put too much effort into this course but still A- only. The course is all about the different ways cities are important to societies. Be it cultural, political, economical, or technological, cities around the world become popular for different reasons. Lots of case studies are given, including Manchester, London, Edo, Angkor Wat, Istanbul, Amsterdam and Melaka, each revolving around a particular theme.\nThere were many profs teaching this course, each talking about their city of expertise. There's basically no lectures, but instead all content is recorded beforehand. It's quite nice to watch actually, as the profs are quite passionate about their cities of interest. This is a fact that they keep bringing up in tutorials as well, as my tutor keeps talking about his home city, to give us a clearer example of the concepts.\nThere are 4 assignments in total, and with tutorial participation, these make up the entirety of your grade. No exam. The first assignment is about selecting a picture of a city and writing a summary about it. What does the picture say about the city? What concepts can you pick up from the lectures? Those types of questions.\nThe second assignment was a documentary critique. They give you around 4 documentaries for you to choose from, then you watch it and write around 600 words about it. The documentaries are like those you'd find on History channel, around 1 hour each. For the critique, you HAVE TO write about both the positives and the negatives. What did the documentary capture accurately about the city? What did they leave out? How does this lead back to the lectures? Why is this documentary significant or insignificant? Don't just applaud it. It's a critique for a reason.\nThe last two assignments are basically just one. It is a creative works assignment, which means you have to create a piece of literature about a city of your choise (no, it can't be Singapore). You have quite a few options to pick from. You can choose to do up a poster, a personal recount, a narrative, a travelogue/travel guide. Quite a lot of freedom. But remember, you always have to link back to the content in the lectures. You are given 1500 words in total. If you're writing a short story, then it's 600 words for the story and 900 words for the write up. Be sure to add lots of references to your work, as they help add credibility."
  },
  "GESS1019": {
    "title": "Urban Planning in Singapore",
    "semester": "AY21/22 S1",
    "grade": "A-",
    "review": "The course is about the history of urban planning in Singapore. "
  }
}